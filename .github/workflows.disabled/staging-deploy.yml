name: Staging Deployment

on:
  push:
    branches: [develop, staging]
  pull_request:
    branches: [main]
    types: [labeled]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy to staging'
        required: true
        default: 'develop'
      environment:
        description: 'Staging environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - preview

concurrency:
  group: staging-deploy-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  deployments: write
  pull-requests: write
  checks: write

env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  NODE_OPTIONS: '--max-old-space-size=4096'
  NEXT_TELEMETRY_DISABLED: 1

jobs:
  # Check if deployment should proceed
  check-deployment:
    name: Check Deployment Conditions
    runs-on: ubuntu-latest
    outputs:
      should-deploy: ${{ steps.check.outputs.should-deploy }}
      environment: ${{ steps.check.outputs.environment }}
      deployment-type: ${{ steps.check.outputs.deployment-type }}
    steps:
      - name: Determine deployment conditions
        id: check
        run: |
          # Check if this is a labeled PR with 'deploy-staging' label
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            if [[ "${{ contains(github.event.pull_request.labels.*.name, 'deploy-staging') }}" == "true" ]]; then
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "environment=staging" >> $GITHUB_OUTPUT
              echo "deployment-type=pr-staging" >> $GITHUB_OUTPUT
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
              echo "PR not labeled for staging deployment"
            fi
          elif [[ "${{ github.ref }}" == "refs/heads/develop" || "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=staging" >> $GITHUB_OUTPUT
            echo "deployment-type=branch-staging" >> $GITHUB_OUTPUT
          elif [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "environment=${{ inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deployment-type=manual" >> $GITHUB_OUTPUT
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
            echo "No staging deployment conditions met"
          fi

  # Staging deployment
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: check-deployment
    if: needs.check-deployment.outputs.should-deploy == 'true'
    timeout-minutes: 15
    environment:
      name: ${{ needs.check-deployment.outputs.environment }}
      url: ${{ steps.deploy.outputs.staging-url }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.branch || github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'
          check-latest: true

      - name: Cache dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.npm
            .next/cache
            node_modules
          key: ${{ runner.os }}-staging-${{ hashFiles('**/package-lock.json') }}-${{ hashFiles('**/*.js', '**/*.jsx', '**/*.ts', '**/*.tsx') }}
          restore-keys: |
            ${{ runner.os }}-staging-${{ hashFiles('**/package-lock.json') }}-
            ${{ runner.os }}-staging-

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --legacy-peer-deps

      - name: Environment validation
        run: npm run validate:env:dev
        continue-on-error: true

      - name: Lint code
        run: npm run lint
        continue-on-error: true

      - name: Type checking
        run: npm run typecheck
        continue-on-error: true

      - name: Run tests
        run: npm run test:run
        env:
          NODE_ENV: test
        continue-on-error: true

      - name: Install Vercel CLI
        run: npm install --global vercel@latest

      - name: Pull Vercel Environment
        run: vercel pull --yes --environment=preview --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project Artifacts
        run: vercel build --token=${{ secrets.VERCEL_TOKEN }}
        env:
          NODE_ENV: production
          NEXT_PUBLIC_APP_URL: https://staging-describe-it.vercel.app
          NEXT_PUBLIC_ENVIRONMENT: staging

      - name: Deploy to Staging
        id: deploy
        run: |
          # Deploy to staging with custom alias
          DEPLOYMENT_URL=$(vercel deploy --prebuilt --token=${{ secrets.VERCEL_TOKEN }})
          
          # Create staging alias
          if [[ "${{ needs.check-deployment.outputs.deployment-type }}" == "pr-staging" ]]; then
            STAGING_URL="https://pr-${{ github.event.pull_request.number }}-describe-it.vercel.app"
            vercel alias "$DEPLOYMENT_URL" "$STAGING_URL" --token=${{ secrets.VERCEL_TOKEN }} || true
          else
            STAGING_URL="https://staging-describe-it.vercel.app"
            vercel alias "$DEPLOYMENT_URL" "$STAGING_URL" --token=${{ secrets.VERCEL_TOKEN }} || true
          fi
          
          echo "staging-url=$STAGING_URL" >> $GITHUB_OUTPUT
          echo "deployment-url=$DEPLOYMENT_URL" >> $GITHUB_OUTPUT
          echo "üöÄ Deployed to staging: $STAGING_URL"

      - name: Wait for staging deployment
        run: |
          echo "Waiting for staging deployment to be ready..."
          npx wait-on "${{ steps.deploy.outputs.staging-url }}" --timeout 180000 --interval 5000

      - name: Basic health check
        run: |
          echo "Running basic health check on staging..."
          curl -f "${{ steps.deploy.outputs.staging-url }}/api/health" || echo "Health check failed"

      - name: Comment on PR with staging URL
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const stagingUrl = '${{ steps.deploy.outputs.staging-url }}';
            const deploymentUrl = '${{ steps.deploy.outputs.deployment-url }}';
            
            const comment = `üöÄ **Staging Deployment Ready**
            
            üì± **Staging URL:** ${stagingUrl}
            üîó **Deployment URL:** ${deploymentUrl}
            üîç **Environment:** Staging
            üìä **Build:** ${{ github.sha }}
            üåø **Branch:** ${{ github.head_ref || github.ref_name }}
            
            ### Quick Links:
            - üåê [Open Staging](${stagingUrl})
            - üîß [View Deployment](${deploymentUrl})
            - üìù [Vercel Dashboard](https://vercel.com/dashboard)
            
            ### Test Checklist:
            - [ ] UI/UX functionality
            - [ ] API endpoints
            - [ ] Authentication flow
            - [ ] Image search
            - [ ] Text generation
            - [ ] Mobile responsiveness
            
            > This staging deployment will be available until the PR is merged or closed.`;
            
            // Update existing comment or create new one
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes('üöÄ **Staging Deployment Ready**')
            );
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

  # Staging validation
  validate-staging:
    name: Validate Staging Deployment
    runs-on: ubuntu-latest
    needs: [check-deployment, deploy-staging]
    if: needs.deploy-staging.result == 'success'
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version-file: '.nvmrc'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci --prefer-offline --no-audit --legacy-peer-deps

      - name: Run staging validation
        run: |
          STAGING_URL="${{ needs.deploy-staging.outputs.staging-url }}"
          if [[ -f "./scripts/validate-deployment.sh" ]]; then
            chmod +x ./scripts/validate-deployment.sh
            ./scripts/validate-deployment.sh "$STAGING_URL"
          else
            echo "üîç Running basic validation..."
            # Basic checks
            curl -f "$STAGING_URL/api/health"
            curl -f "$STAGING_URL" | grep -q "<!DOCTYPE html"
            echo "‚úÖ Basic validation passed"
          fi

      - name: Run smoke tests on staging
        run: npm run test:smoke
        env:
          TEST_URL: ${{ needs.deploy-staging.outputs.staging-url }}
        continue-on-error: true

      - name: Performance check
        run: npm run test:vitals
        env:
          TEST_URL: ${{ needs.deploy-staging.outputs.staging-url }}
        continue-on-error: true

  # Update deployment status
  update-deployment-status:
    name: Update Deployment Status
    runs-on: ubuntu-latest
    needs: [check-deployment, deploy-staging, validate-staging]
    if: always() && needs.check-deployment.outputs.should-deploy == 'true'
    steps:
      - name: Update GitHub deployment status
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentState = '${{ needs.validate-staging.result }}' === 'success' ? 'success' : 'failure';
            const stagingUrl = '${{ needs.deploy-staging.outputs.staging-url }}';
            const environment = '${{ needs.check-deployment.outputs.environment }}';
            
            // Create deployment record
            try {
              const { data: deployment } = await github.rest.repos.createDeployment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: '${{ github.sha }}',
                environment: environment,
                description: `Staging deployment (${environment})`,
                auto_merge: false,
                required_contexts: []
              });
              
              // Update deployment status
              await github.rest.repos.createDeploymentStatus({
                owner: context.repo.owner,
                repo: context.repo.repo,
                deployment_id: deployment.id,
                state: deploymentState,
                environment_url: stagingUrl,
                description: deploymentState === 'success' ? 'Staging deployment successful' : 'Staging deployment failed'
              });
              
              console.log(`Deployment status updated: ${deploymentState}`);
            } catch (error) {
              console.error('Failed to update deployment status:', error);
            }

      - name: Create deployment summary
        run: |
          echo "## üé≠ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.check-deployment.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Type:** ${{ needs.check-deployment.outputs.deployment-type }}" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** ${{ needs.validate-staging.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Links" >> $GITHUB_STEP_SUMMARY
          if [[ -n "${{ needs.deploy-staging.outputs.staging-url }}" ]]; then
            echo "- [üåê Staging URL](${{ needs.deploy-staging.outputs.staging-url }})" >> $GITHUB_STEP_SUMMARY
          fi
          echo "- [üìä Vercel Dashboard](https://vercel.com/dashboard)" >> $GITHUB_STEP_SUMMARY
          echo "- [üìù Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY

  # Auto-cleanup old staging deployments
  cleanup-old-deployments:
    name: Cleanup Old Deployments
    runs-on: ubuntu-latest
    needs: [deploy-staging, validate-staging]
    if: always() && needs.deploy-staging.result == 'success'
    steps:
      - name: Cleanup old staging deployments
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Get all deployments for staging environment
              const { data: deployments } = await github.rest.repos.listDeployments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                environment: 'staging',
                per_page: 100
              });
              
              // Keep only the 5 most recent deployments, mark others as inactive
              const deploymentsToInactivate = deployments.slice(5);
              
              for (const deployment of deploymentsToInactivate) {
                await github.rest.repos.createDeploymentStatus({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  deployment_id: deployment.id,
                  state: 'inactive',
                  description: 'Cleaned up old staging deployment'
                });
              }
              
              console.log(`Cleaned up ${deploymentsToInactivate.length} old staging deployments`);
            } catch (error) {
              console.error('Failed to cleanup old deployments:', error);
            }