import { useState, useCallback, useEffect } from 'react';\nimport { AnswerSession, Question, UserAnswer } from '@/types';\n\ninterface UseAnswerSessionReturn {\n  session: AnswerSession | null;\n  loading: boolean;\n  error: string | null;\n  startSession: (imageId: string, questions: Question[]) => void;\n  submitAnswer: (questionId: string, answer: string) => Promise<boolean>;\n  nextQuestion: () => void;\n  prevQuestion: () => void;\n  completeSession: () => void;\n  resetSession: () => void;\n}\n\nexport function useAnswerSession(): UseAnswerSessionReturn {\n  const [session, setSession] = useState<AnswerSession | null>(null);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const startSession = useCallback((imageId: string, questions: Question[]) => {\n    const newSession: AnswerSession = {\n      id: `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      imageId,\n      questions,\n      userAnswers: [],\n      currentQuestionIndex: 0,\n      completed: false,\n      score: 0\n    };\n    \n    setSession(newSession);\n    setError(null);\n  }, []);\n\n  const submitAnswer = useCallback(async (questionId: string, answer: string): Promise<boolean> => {\n    if (!session) return false;\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Simulate API call to check answer\n      const question = session.questions.find(q => q.id === questionId);\n      if (!question) {\n        throw new Error('Question not found');\n      }\n\n      // Simple answer checking logic (in real app, this would be more sophisticated)\n      const isCorrect = checkAnswer(answer, question.expectedAnswer);\n      \n      const userAnswer: UserAnswer = {\n        questionId,\n        answer,\n        isCorrect,\n        timestamp: new Date().toISOString()\n      };\n\n      setSession(prev => {\n        if (!prev) return prev;\n        \n        const updatedAnswers = [...prev.userAnswers, userAnswer];\n        const correctAnswers = updatedAnswers.filter(a => a.isCorrect).length;\n        const score = Math.round((correctAnswers / prev.questions.length) * 100);\n        \n        return {\n          ...prev,\n          userAnswers: updatedAnswers,\n          score\n        };\n      });\n\n      return isCorrect;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : 'Failed to submit answer');\n      return false;\n    } finally {\n      setLoading(false);\n    }\n  }, [session]);\n\n  const nextQuestion = useCallback(() => {\n    if (!session) return;\n    \n    const nextIndex = Math.min(session.currentQuestionIndex + 1, session.questions.length - 1);\n    setSession(prev => prev ? { ...prev, currentQuestionIndex: nextIndex } : prev);\n  }, [session]);\n\n  const prevQuestion = useCallback(() => {\n    if (!session) return;\n    \n    const prevIndex = Math.max(session.currentQuestionIndex - 1, 0);\n    setSession(prev => prev ? { ...prev, currentQuestionIndex: prevIndex } : prev);\n  }, [session]);\n\n  const completeSession = useCallback(() => {\n    if (!session) return;\n    \n    setSession(prev => prev ? { ...prev, completed: true } : prev);\n  }, [session]);\n\n  const resetSession = useCallback(() => {\n    setSession(null);\n    setError(null);\n  }, []);\n\n  // Auto-complete session when all questions are answered\n  useEffect(() => {\n    if (session && !session.completed) {\n      const allQuestionsAnswered = session.questions.every(question => \n        session.userAnswers.some(answer => answer.questionId === question.id)\n      );\n      \n      if (allQuestionsAnswered) {\n        completeSession();\n      }\n    }\n  }, [session, completeSession]);\n\n  return {\n    session,\n    loading,\n    error,\n    startSession,\n    submitAnswer,\n    nextQuestion,\n    prevQuestion,\n    completeSession,\n    resetSession\n  };\n}\n\n// Simple answer checking function\nfunction checkAnswer(userAnswer: string, expectedAnswer: string): boolean {\n  const normalizeText = (text: string) => \n    text.toLowerCase()\n        .replace(/[^a-z0-9\\s]/g, '')\n        .replace(/\\s+/g, ' ')\n        .trim();\n  \n  const normalizedUser = normalizeText(userAnswer);\n  const normalizedExpected = normalizeText(expectedAnswer);\n  \n  // Exact match\n  if (normalizedUser === normalizedExpected) {\n    return true;\n  }\n  \n  // Check if user answer contains key words from expected answer\n  const expectedWords = normalizedExpected.split(' ').filter(word => word.length > 3);\n  const userWords = normalizedUser.split(' ');\n  \n  const matchingWords = expectedWords.filter(word => \n    userWords.some(userWord => userWord.includes(word) || word.includes(userWord))\n  );\n  \n  // Consider correct if at least 60% of important words match\n  return matchingWords.length >= Math.ceil(expectedWords.length * 0.6);\n}"