/**
 * Services Index - Central registry for all services
 * Provides unified access to all application services
 */

// Import all services
export { openAIService, OpenAIService } from './openaiService';\nexport { translationService, TranslationService } from './translationService';\nexport { vocabularyService } from './vocabularyService'; // Original service\nexport { enhancedVocabularyService, EnhancedVocabularyService } from './enhancedVocabularyService';\nexport { qaService, QAService } from './qaService';\nexport { progressService, ProgressService } from './progressService';\nexport { exportService, ExportService } from './exportService';\n\n// Service health check interface\ninterface ServiceHealth {\n  name: string;\n  healthy: boolean;\n  lastCheck: string;\n  error?: string;\n  responseTime?: number;\n}\n\n// Service registry for managing all services\nexport class ServiceRegistry {\n  private services: Map<string, any> = new Map();\n  private healthStatus: Map<string, ServiceHealth> = new Map();\n\n  constructor() {\n    this.registerServices();\n  }\n\n  private registerServices(): void {\n    // Register all services\n    this.services.set('openai', openAIService);\n    this.services.set('translation', translationService);\n    this.services.set('vocabulary', vocabularyService);\n    this.services.set('enhancedVocabulary', enhancedVocabularyService);\n    this.services.set('qa', qaService);\n    this.services.set('progress', progressService);\n    this.services.set('export', exportService);\n  }\n\n  /**\n   * Get a service by name\n   */\n  public getService<T = any>(name: string): T | null {\n    return this.services.get(name) || null;\n  }\n\n  /**\n   * Check if a service is registered\n   */\n  public hasService(name: string): boolean {\n    return this.services.has(name);\n  }\n\n  /**\n   * Get all registered service names\n   */\n  public getServiceNames(): string[] {\n    return Array.from(this.services.keys());\n  }\n\n  /**\n   * Perform health checks on all services\n   */\n  public async performHealthChecks(): Promise<ServiceHealth[]> {\n    const healthChecks = [];\n    const timestamp = new Date().toISOString();\n\n    for (const [name, service] of this.services.entries()) {\n      const startTime = Date.now();\n      let health: ServiceHealth = {\n        name,\n        healthy: false,\n        lastCheck: timestamp,\n      };\n\n      try {\n        // Check if service has a health check method\n        if (typeof service.healthCheck === 'function') {\n          const result = await service.healthCheck();\n          health.healthy = result.healthy || result === true;\n          health.error = result.error;\n        } else {\n          // Fallback: check if service is available\n          health.healthy = service !== null && service !== undefined;\n        }\n        \n        health.responseTime = Date.now() - startTime;\n      } catch (error) {\n        health.healthy = false;\n        health.error = error instanceof Error ? error.message : 'Health check failed';\n        health.responseTime = Date.now() - startTime;\n      }\n\n      this.healthStatus.set(name, health);\n      healthChecks.push(health);\n    }\n\n    return healthChecks;\n  }\n\n  /**\n   * Get health status for a specific service\n   */\n  public getServiceHealth(name: string): ServiceHealth | null {\n    return this.healthStatus.get(name) || null;\n  }\n\n  /**\n   * Get overall system health\n   */\n  public getSystemHealth(): {\n    healthy: boolean;\n    totalServices: number;\n    healthyServices: number;\n    unhealthyServices: number;\n    services: ServiceHealth[];\n  } {\n    const services = Array.from(this.healthStatus.values());\n    const healthyServices = services.filter(s => s.healthy).length;\n    \n    return {\n      healthy: healthyServices === services.length,\n      totalServices: services.length,\n      healthyServices,\n      unhealthyServices: services.length - healthyServices,\n      services,\n    };\n  }\n\n  /**\n   * Initialize all services (call any initialization methods)\n   */\n  public async initializeServices(): Promise<void> {\n    const initPromises = [];\n\n    for (const [name, service] of this.services.entries()) {\n      if (typeof service.initialize === 'function') {\n        console.log(`Initializing service: ${name}`);\n        initPromises.push(\n          service.initialize().catch((error: Error) => {\n            console.warn(`Failed to initialize service ${name}:`, error.message);\n          })\n        );\n      }\n    }\n\n    await Promise.all(initPromises);\n  }\n\n  /**\n   * Cleanup all services\n   */\n  public async cleanup(): Promise<void> {\n    const cleanupPromises = [];\n\n    for (const [name, service] of this.services.entries()) {\n      if (typeof service.cleanup === 'function') {\n        console.log(`Cleaning up service: ${name}`);\n        cleanupPromises.push(\n          service.cleanup().catch((error: Error) => {\n            console.warn(`Failed to cleanup service ${name}:`, error.message);\n          })\n        );\n      }\n\n      // Clear caches if available\n      if (typeof service.clearCache === 'function') {\n        try {\n          service.clearCache();\n        } catch (error) {\n          console.warn(`Failed to clear cache for service ${name}:`, error);\n        }\n      }\n    }\n\n    await Promise.all(cleanupPromises);\n  }\n\n  /**\n   * Get service statistics\n   */\n  public async getServiceStatistics(): Promise<Record<string, any>> {\n    const stats: Record<string, any> = {};\n\n    for (const [name, service] of this.services.entries()) {\n      try {\n        if (typeof service.getStats === 'function') {\n          stats[name] = await service.getStats();\n        } else if (typeof service.getCacheStats === 'function') {\n          stats[name] = service.getCacheStats();\n        } else {\n          stats[name] = { available: true };\n        }\n      } catch (error) {\n        stats[name] = { \n          error: error instanceof Error ? error.message : 'Failed to get stats',\n          available: false \n        };\n      }\n    }\n\n    return stats;\n  }\n}\n\n// Create and export singleton registry\nexport const serviceRegistry = new ServiceRegistry();\n\n// Convenience exports for commonly used services\nexport {\n  openAIService as openai,\n  translationService as translation,\n  vocabularyService as vocabulary,\n  enhancedVocabularyService as enhancedVocabulary,\n  qaService as qa,\n  progressService as progress,\n  exportService as export,\n};\n\n// Default export\nexport default serviceRegistry;\n\n// Types for external use\nexport type { ServiceHealth };\n\n// Service configuration types\nexport interface ServiceConfig {\n  retryAttempts?: number;\n  timeout?: number;\n  cacheEnabled?: boolean;\n  cacheTTL?: number;\n}\n\n// Common service interface\nexport interface BaseService {\n  healthCheck?(): Promise<{ healthy: boolean; error?: string }> | boolean;\n  initialize?(): Promise<void>;\n  cleanup?(): Promise<void>;\n  clearCache?(): void;\n  getStats?(): Promise<any> | any;\n  getCacheStats?(): any;\n}\n\n/**\n * Service factory for creating configured services\n */\nexport class ServiceFactory {\n  /**\n   * Create a configured OpenAI service\n   */\n  static createOpenAIService(config?: ServiceConfig): OpenAIService {\n    return new OpenAIService();\n  }\n\n  /**\n   * Create a configured translation service\n   */\n  static createTranslationService(config?: ServiceConfig): TranslationService {\n    return new TranslationService();\n  }\n\n  /**\n   * Create a configured enhanced vocabulary service\n   */\n  static createEnhancedVocabularyService(config?: ServiceConfig): EnhancedVocabularyService {\n    return new EnhancedVocabularyService();\n  }\n\n  /**\n   * Create a configured Q&A service\n   */\n  static createQAService(config?: ServiceConfig): QAService {\n    return new QAService();\n  }\n\n  /**\n   * Create a configured progress service\n   */\n  static createProgressService(config?: ServiceConfig): ProgressService {\n    return new ProgressService();\n  }\n\n  /**\n   * Create a configured export service\n   */\n  static createExportService(config?: ServiceConfig): ExportService {\n    return new ExportService();\n  }\n}\n\n/**\n * Utility functions for service management\n */\nexport const ServiceUtils = {\n  /**\n   * Wait for all services to be healthy\n   */\n  async waitForHealthyServices(registry: ServiceRegistry, timeout: number = 30000): Promise<boolean> {\n    const startTime = Date.now();\n    \n    while (Date.now() - startTime < timeout) {\n      const health = await registry.performHealthChecks();\n      const allHealthy = health.every(s => s.healthy);\n      \n      if (allHealthy) {\n        return true;\n      }\n      \n      // Wait 1 second before checking again\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n    \n    return false;\n  },\n\n  /**\n   * Get services by category/type\n   */\n  getServicesByType(registry: ServiceRegistry, type: 'ai' | 'storage' | 'analysis' | 'export'): string[] {\n    const typeMap = {\n      ai: ['openai', 'translation'],\n      storage: ['vocabulary', 'enhancedVocabulary', 'progress'],\n      analysis: ['qa'],\n      export: ['export'],\n    };\n    \n    return typeMap[type] || [];\n  },\n\n  /**\n   * Create service health report\n   */\n  createHealthReport(registry: ServiceRegistry): string {\n    const systemHealth = registry.getSystemHealth();\n    let report = `\\n=== Service Health Report ===\\n`;\n    report += `Generated: ${new Date().toISOString()}\\n`;\n    report += `Overall Status: ${systemHealth.healthy ? '✅ HEALTHY' : '❌ UNHEALTHY'}\\n`;\n    report += `Services: ${systemHealth.healthyServices}/${systemHealth.totalServices} healthy\\n\\n`;\n    \n    systemHealth.services.forEach(service => {\n      const status = service.healthy ? '✅' : '❌';\n      const responseTime = service.responseTime ? ` (${service.responseTime}ms)` : '';\n      const error = service.error ? ` - ${service.error}` : '';\n      \n      report += `${status} ${service.name}${responseTime}${error}\\n`;\n    });\n    \n    return report;\n  },\n};