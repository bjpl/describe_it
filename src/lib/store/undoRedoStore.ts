import React from 'react';
import { create } from 'zustand';
import { devtools, subscribeWithSelector } from 'zustand/middleware';
import { createShallowSelector } from '../utils/storeUtils';
import { safeParse, safeStringify } from "@/lib/utils/json-safe";

/**
 * Undo/Redo Store - Universal undo/redo functionality for any store
 * Features:
 * - Multi-store undo/redo support
 * - Action grouping and batching
 * - Selective property tracking
 * - Branch management for non-linear history
 * - Auto-cleanup of old history
 * - Compression for large states
 * - Metadata tracking
 */

export interface HistoryEntry {
  id: string;
  timestamp: Date;
  storeKey: string;
  actionName: string;
  previousState: any;
  nextState: any;
  metadata?: {
    userId?: string;
    sessionId?: string;
    tags?: string[];
    description?: string;
  };
  compressed?: boolean;
}

export interface HistoryBranch {
  id: string;
  name: string;
  entries: HistoryEntry[];
  parentBranchId?: string;
  createdAt: Date;
}

export interface UndoRedoConfig {
  maxHistorySize: number;
  compressionThreshold: number; // Size in bytes to trigger compression
  autoCleanupMs: number; // Time in ms after which old entries are removed
  trackingStrategies: {
    [storeKey: string]: 'full' | 'selective' | 'none';
  };
  selectiveProps: {
    [storeKey: string]: string[];
  };
  groupingEnabled: boolean;
  groupingTimeoutMs: number;
}\n\ninterface UndoRedoState {\n  // History management\n  branches: Map<string, HistoryBranch>;\n  currentBranchId: string;\n  currentIndex: number; // Index within current branch\n  \n  // Configuration\n  config: UndoRedoConfig;\n  \n  // Registered stores\n  registeredStores: Map<string, {\n    getState: () => any;\n    setState: (state: any, actionName?: string) => void;\n    subscribe: (callback: (state: any) => void) => () => void;\n  }>;\n  \n  // Action grouping\n  currentGroup: {\n    id: string;\n    entries: HistoryEntry[];\n    timeout: NodeJS.Timeout | null;\n  } | null;\n  \n  // Actions\n  registerStore: (storeKey: string, storeInterface: any, strategy?: 'full' | 'selective' | 'none') => void;\n  unregisterStore: (storeKey: string) => void;\n  \n  // History operations\n  canUndo: (storeKey?: string) => boolean;\n  canRedo: (storeKey?: string) => boolean;\n  undo: (storeKey?: string) => boolean;\n  redo: (storeKey?: string) => boolean;\n  \n  // Batch operations\n  startGroup: (description?: string) => void;\n  endGroup: () => void;\n  \n  // Branch management\n  createBranch: (name: string, fromCurrentState?: boolean) => string;\n  switchBranch: (branchId: string) => boolean;\n  deleteBranch: (branchId: string) => void;\n  mergeBranch: (sourceBranchId: string, targetBranchId: string) => boolean;\n  \n  // History queries\n  getHistory: (storeKey?: string, limit?: number) => HistoryEntry[];\n  getHistorySize: (storeKey?: string) => number;\n  clearHistory: (storeKey?: string) => void;\n  \n  // State utilities\n  jumpToEntry: (entryId: string) => boolean;\n  getStateAt: (timestamp: Date, storeKey: string) => any;\n  \n  // Internal methods\n  _recordEntry: (storeKey: string, actionName: string, previousState: any, nextState: any, metadata?: any) => void;\n  _compressEntry: (entry: HistoryEntry) => HistoryEntry;\n  _cleanup: () => void;\n  _shouldTrack: (storeKey: string, actionName?: string) => boolean;\n  _extractTrackedState: (storeKey: string, fullState: any) => any;\n}\n\n// Default configuration\nconst defaultConfig: UndoRedoConfig = {\n  maxHistorySize: 100,\n  compressionThreshold: 1024 * 10, // 10KB\n  autoCleanupMs: 1000 * 60 * 60 * 24, // 24 hours\n  trackingStrategies: {},\n  selectiveProps: {},\n  groupingEnabled: true,\n  groupingTimeoutMs: 500\n};\n\n// Compression utilities\nconst compressState = (state: any): string => {\n  try {\n    const json = JSON.stringify(state);\n    // Simple compression - in production, use a real compression library\n    return btoa(json);\n  } catch {\n    return '';\n  }\n};\n\nconst decompressState = (compressed: string): any => {\n  try {\n    return JSON.parse(atob(compressed));\n  } catch {\n    return null;\n  }\n};\n\n// Generate unique IDs\nconst generateId = (): string => {\n  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n\nexport const useUndoRedoStore = create<UndoRedoState>()(  \n  devtools(\n    subscribeWithSelector(\n      (set, get) => {\n        let cleanupInterval: NodeJS.Timeout | null = null;\n        \n        // Initialize cleanup interval\n        if (typeof window !== 'undefined') {\n          cleanupInterval = setInterval(() => {\n            get()._cleanup();\n          }, 60000); // Run cleanup every minute\n        }\n        \n        return {\n          branches: new Map([[\n            'main', \n            {\n              id: 'main',\n              name: 'Main',\n              entries: [],\n              createdAt: new Date()\n            }\n          ]]),\n          currentBranchId: 'main',\n          currentIndex: -1,\n          config: defaultConfig,\n          registeredStores: new Map(),\n          currentGroup: null,\n          \n          registerStore: (storeKey, storeInterface, strategy = 'full') => {\n            const state = get();\n            \n            // Set tracking strategy\n            set((state) => ({\n              config: {\n                ...state.config,\n                trackingStrategies: {\n                  ...state.config.trackingStrategies,\n                  [storeKey]: strategy\n                }\n              }\n            }), false, 'setTrackingStrategy');\n            \n            // Register store interface\n            const registeredStores = new Map(state.registeredStores);\n            registeredStores.set(storeKey, storeInterface);\n            \n            // Subscribe to store changes\n            const unsubscribe = storeInterface.subscribe((newState: any, actionName?: string) => {\n              const currentState = get();\n              if (!currentState._shouldTrack(storeKey, actionName)) return;\n              \n              // Get previous state for comparison\n              const currentBranch = currentState.branches.get(currentState.currentBranchId);\n              let previousState = null;\n              \n              if (currentBranch && currentState.currentIndex >= 0) {\n                const lastEntry = currentBranch.entries[currentState.currentIndex];\n                if (lastEntry && lastEntry.storeKey === storeKey) {\n                  previousState = lastEntry.nextState;\n                }\n              }\n              \n              if (!previousState) {\n                previousState = currentState._extractTrackedState(storeKey, storeInterface.getState());\n              }\n              \n              const trackedNewState = currentState._extractTrackedState(storeKey, newState);\n              \n              // Only record if state actually changed\n              if (JSON.stringify(previousState) !== JSON.stringify(trackedNewState)) {\n                currentState._recordEntry(\n                  storeKey,\n                  actionName || 'unknown',\n                  previousState,\n                  trackedNewState\n                );\n              }\n            });\n            \n            // Store cleanup function with store interface\n            registeredStores.set(storeKey, {\n              ...storeInterface,\n              _unsubscribe: unsubscribe\n            });\n            \n            set({ registeredStores }, false, 'registerStore');\n          },\n          \n          unregisterStore: (storeKey) => {\n            const state = get();\n            const storeInterface = state.registeredStores.get(storeKey);\n            \n            if (storeInterface && (storeInterface as any)._unsubscribe) {\n              (storeInterface as any)._unsubscribe();\n            }\n            \n            const newRegisteredStores = new Map(state.registeredStores);\n            newRegisteredStores.delete(storeKey);\n            \n            set({ registeredStores: newRegisteredStores }, false, 'unregisterStore');\n          },\n          \n          canUndo: (storeKey) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch || state.currentIndex < 0) return false;\n            \n            if (storeKey) {\n              // Check if there's an entry for this specific store to undo\n              for (let i = state.currentIndex; i >= 0; i--) {\n                if (currentBranch.entries[i].storeKey === storeKey) {\n                  return true;\n                }\n              }\n              return false;\n            }\n            \n            return state.currentIndex >= 0;\n          },\n          \n          canRedo: (storeKey) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch || state.currentIndex >= currentBranch.entries.length - 1) return false;\n            \n            if (storeKey) {\n              // Check if there's an entry for this specific store to redo\n              for (let i = state.currentIndex + 1; i < currentBranch.entries.length; i++) {\n                if (currentBranch.entries[i].storeKey === storeKey) {\n                  return true;\n                }\n              }\n              return false;\n            }\n            \n            return state.currentIndex < currentBranch.entries.length - 1;\n          },\n          \n          undo: (storeKey) => {\n            const state = get();\n            if (!state.canUndo(storeKey)) return false;\n            \n            const currentBranch = state.branches.get(state.currentBranchId)!;\n            let targetIndex = state.currentIndex;\n            \n            if (storeKey) {\n              // Find the most recent entry for this store\n              for (let i = state.currentIndex; i >= 0; i--) {\n                if (currentBranch.entries[i].storeKey === storeKey) {\n                  const entry = currentBranch.entries[i];\n                  const storeInterface = state.registeredStores.get(storeKey);\n                  \n                  if (storeInterface) {\n                    const stateToRestore = entry.compressed \n                      ? decompressState(entry.previousState)\n                      : entry.previousState;\n                      \n                    storeInterface.setState(stateToRestore, `undo:${entry.actionName}`);\n                  }\n                  \n                  targetIndex = i - 1;\n                  break;\n                }\n              }\n            } else {\n              // Undo the last action regardless of store\n              const entry = currentBranch.entries[state.currentIndex];\n              const storeInterface = state.registeredStores.get(entry.storeKey);\n              \n              if (storeInterface) {\n                const stateToRestore = entry.compressed \n                  ? decompressState(entry.previousState)\n                  : entry.previousState;\n                  \n                storeInterface.setState(stateToRestore, `undo:${entry.actionName}`);\n              }\n              \n              targetIndex = state.currentIndex - 1;\n            }\n            \n            set({ currentIndex: targetIndex }, false, 'undo');\n            return true;\n          },\n          \n          redo: (storeKey) => {\n            const state = get();\n            if (!state.canRedo(storeKey)) return false;\n            \n            const currentBranch = state.branches.get(state.currentBranchId)!;\n            let targetIndex = state.currentIndex;\n            \n            if (storeKey) {\n              // Find the next entry for this store\n              for (let i = state.currentIndex + 1; i < currentBranch.entries.length; i++) {\n                if (currentBranch.entries[i].storeKey === storeKey) {\n                  const entry = currentBranch.entries[i];\n                  const storeInterface = state.registeredStores.get(storeKey);\n                  \n                  if (storeInterface) {\n                    const stateToRestore = entry.compressed \n                      ? decompressState(entry.nextState)\n                      : entry.nextState;\n                      \n                    storeInterface.setState(stateToRestore, `redo:${entry.actionName}`);\n                  }\n                  \n                  targetIndex = i;\n                  break;\n                }\n              }\n            } else {\n              // Redo the next action\n              const entry = currentBranch.entries[state.currentIndex + 1];\n              const storeInterface = state.registeredStores.get(entry.storeKey);\n              \n              if (storeInterface) {\n                const stateToRestore = entry.compressed \n                  ? decompressState(entry.nextState)\n                  : entry.nextState;\n                  \n                storeInterface.setState(stateToRestore, `redo:${entry.actionName}`);\n              }\n              \n              targetIndex = state.currentIndex + 1;\n            }\n            \n            set({ currentIndex: targetIndex }, false, 'redo');\n            return true;\n          },\n          \n          startGroup: (description) => {\n            const state = get();\n            \n            // End current group if exists\n            if (state.currentGroup) {\n              get().endGroup();\n            }\n            \n            set({\n              currentGroup: {\n                id: generateId(),\n                entries: [],\n                timeout: null\n              }\n            }, false, 'startGroup');\n          },\n          \n          endGroup: () => {\n            const state = get();\n            if (!state.currentGroup) return;\n            \n            if (state.currentGroup.timeout) {\n              clearTimeout(state.currentGroup.timeout);\n            }\n            \n            // If group has entries, they're already recorded individually\n            // Just clear the group\n            set({ currentGroup: null }, false, 'endGroup');\n          },\n          \n          createBranch: (name, fromCurrentState = true) => {\n            const branchId = generateId();\n            const state = get();\n            \n            const newBranch: HistoryBranch = {\n              id: branchId,\n              name,\n              entries: [],\n              parentBranchId: state.currentBranchId,\n              createdAt: new Date()\n            };\n            \n            // Copy current history up to current index if requested\n            if (fromCurrentState) {\n              const currentBranch = state.branches.get(state.currentBranchId);\n              if (currentBranch) {\n                newBranch.entries = currentBranch.entries.slice(0, state.currentIndex + 1);\n              }\n            }\n            \n            const newBranches = new Map(state.branches);\n            newBranches.set(branchId, newBranch);\n            \n            set({ branches: newBranches }, false, 'createBranch');\n            \n            return branchId;\n          },\n          \n          switchBranch: (branchId) => {\n            const state = get();\n            const targetBranch = state.branches.get(branchId);\n            \n            if (!targetBranch) return false;\n            \n            // Apply all states from the target branch\n            targetBranch.entries.forEach(entry => {\n              const storeInterface = state.registeredStores.get(entry.storeKey);\n              if (storeInterface) {\n                const stateToApply = entry.compressed \n                  ? decompressState(entry.nextState)\n                  : entry.nextState;\n                  \n                storeInterface.setState(stateToApply, `branch:${entry.actionName}`);\n              }\n            });\n            \n            set({\n              currentBranchId: branchId,\n              currentIndex: targetBranch.entries.length - 1\n            }, false, 'switchBranch');\n            \n            return true;\n          },\n          \n          deleteBranch: (branchId) => {\n            if (branchId === 'main') return; // Can't delete main branch\n            \n            const state = get();\n            const newBranches = new Map(state.branches);\n            newBranches.delete(branchId);\n            \n            let newCurrentBranchId = state.currentBranchId;\n            if (state.currentBranchId === branchId) {\n              newCurrentBranchId = 'main';\n            }\n            \n            set({\n              branches: newBranches,\n              currentBranchId: newCurrentBranchId,\n              currentIndex: newBranches.get(newCurrentBranchId)?.entries.length - 1 || -1\n            }, false, 'deleteBranch');\n          },\n          \n          mergeBranch: (sourceBranchId, targetBranchId) => {\n            const state = get();\n            const sourceBranch = state.branches.get(sourceBranchId);\n            const targetBranch = state.branches.get(targetBranchId);\n            \n            if (!sourceBranch || !targetBranch) return false;\n            \n            // Merge source branch entries into target branch\n            const mergedEntries = [...targetBranch.entries, ...sourceBranch.entries];\n            \n            const newBranches = new Map(state.branches);\n            newBranches.set(targetBranchId, {\n              ...targetBranch,\n              entries: mergedEntries\n            });\n            \n            set({ branches: newBranches }, false, 'mergeBranch');\n            \n            return true;\n          },\n          \n          getHistory: (storeKey, limit) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch) return [];\n            \n            let entries = currentBranch.entries;\n            \n            if (storeKey) {\n              entries = entries.filter(entry => entry.storeKey === storeKey);\n            }\n            \n            if (limit && entries.length > limit) {\n              entries = entries.slice(-limit);\n            }\n            \n            return entries;\n          },\n          \n          getHistorySize: (storeKey) => {\n            return get().getHistory(storeKey).length;\n          },\n          \n          clearHistory: (storeKey) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch) return;\n            \n            let newEntries = currentBranch.entries;\n            \n            if (storeKey) {\n              newEntries = newEntries.filter(entry => entry.storeKey !== storeKey);\n            } else {\n              newEntries = [];\n            }\n            \n            const newBranches = new Map(state.branches);\n            newBranches.set(state.currentBranchId, {\n              ...currentBranch,\n              entries: newEntries\n            });\n            \n            set({\n              branches: newBranches,\n              currentIndex: newEntries.length - 1\n            }, false, 'clearHistory');\n          },\n          \n          jumpToEntry: (entryId) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch) return false;\n            \n            const entryIndex = currentBranch.entries.findIndex(entry => entry.id === entryId);\n            \n            if (entryIndex === -1) return false;\n            \n            // Apply all states up to the target entry\n            for (let i = 0; i <= entryIndex; i++) {\n              const entry = currentBranch.entries[i];\n              const storeInterface = state.registeredStores.get(entry.storeKey);\n              \n              if (storeInterface) {\n                const stateToApply = entry.compressed \n                  ? decompressState(entry.nextState)\n                  : entry.nextState;\n                  \n                storeInterface.setState(stateToApply, `jump:${entry.actionName}`);\n              }\n            }\n            \n            set({ currentIndex: entryIndex }, false, 'jumpToEntry');\n            \n            return true;\n          },\n          \n          getStateAt: (timestamp, storeKey) => {\n            const state = get();\n            const currentBranch = state.branches.get(state.currentBranchId);\n            \n            if (!currentBranch) return null;\n            \n            // Find the last entry for this store before or at the timestamp\n            for (let i = currentBranch.entries.length - 1; i >= 0; i--) {\n              const entry = currentBranch.entries[i];\n              if (entry.storeKey === storeKey && entry.timestamp <= timestamp) {\n                return entry.compressed \n                  ? decompressState(entry.nextState)\n                  : entry.nextState;\n              }\n            }\n            \n            return null;\n          },\n          \n          _recordEntry: (storeKey, actionName, previousState, nextState, metadata) => {\n            const state = get();\n            \n            const entry: HistoryEntry = {\n              id: generateId(),\n              timestamp: new Date(),\n              storeKey,\n              actionName,\n              previousState,\n              nextState,\n              metadata\n            };\n            \n            // Check if compression is needed\n            const entrySize = JSON.stringify(entry).length;\n            if (entrySize > state.config.compressionThreshold) {\n              entry.previousState = compressState(previousState);\n              entry.nextState = compressState(nextState);\n              entry.compressed = true;\n            }\n            \n            const currentBranch = state.branches.get(state.currentBranchId)!;\n            \n            // If we're not at the end of history, create a new branch\n            let targetBranch = currentBranch;\n            let targetBranchId = state.currentBranchId;\n            \n            if (state.currentIndex < currentBranch.entries.length - 1) {\n              // Create new branch from current position\n              targetBranchId = get().createBranch(`Auto-${Date.now()}`, true);\n              targetBranch = state.branches.get(targetBranchId)!;\n            }\n            \n            // Add entry to branch\n            const newEntries = [...targetBranch.entries, entry];\n            \n            // Maintain max history size\n            if (newEntries.length > state.config.maxHistorySize) {\n              newEntries.shift(); // Remove oldest entry\n            }\n            \n            const newBranches = new Map(state.branches);\n            newBranches.set(targetBranchId, {\n              ...targetBranch,\n              entries: newEntries\n            });\n            \n            set({\n              branches: newBranches,\n              currentBranchId: targetBranchId,\n              currentIndex: newEntries.length - 1\n            }, false, 'recordEntry');\n          },\n          \n          _compressEntry: (entry) => {\n            return {\n              ...entry,\n              previousState: compressState(entry.previousState),\n              nextState: compressState(entry.nextState),\n              compressed: true\n            };\n          },\n          \n          _cleanup: () => {\n            const state = get();\n            const cutoffTime = Date.now() - state.config.autoCleanupMs;\n            let hasChanges = false;\n            \n            const newBranches = new Map();\n            \n            state.branches.forEach((branch, branchId) => {\n              const filteredEntries = branch.entries.filter(\n                entry => entry.timestamp.getTime() > cutoffTime\n              );\n              \n              if (filteredEntries.length !== branch.entries.length) {\n                hasChanges = true;\n              }\n              \n              newBranches.set(branchId, {\n                ...branch,\n                entries: filteredEntries\n              });\n            });\n            \n            if (hasChanges) {\n              set({ branches: newBranches }, false, 'cleanup');\n            }\n          },\n          \n          _shouldTrack: (storeKey, actionName) => {\n            const state = get();\n            const strategy = state.config.trackingStrategies[storeKey] || 'full';\n            \n            if (strategy === 'none') return false;\n            \n            // Don't track undo/redo actions to prevent infinite loops\n            if (actionName?.startsWith('undo:') || actionName?.startsWith('redo:')) {\n              return false;\n            }\n            \n            return true;\n          },\n          \n          _extractTrackedState: (storeKey, fullState) => {\n            const state = get();\n            const strategy = state.config.trackingStrategies[storeKey] || 'full';\n            \n            if (strategy === 'selective') {\n              const propsToTrack = state.config.selectiveProps[storeKey] || [];\n              const trackedState: any = {};\n              \n              propsToTrack.forEach(prop => {\n                if (prop in fullState) {\n                  trackedState[prop] = fullState[prop];\n                }\n              });\n              \n              return trackedState;\n            }\n            \n            return fullState;\n          }\n        };\n      }\n    ),\n    { name: 'UndoRedoStore' }\n  )\n);\n\n// Selectors\nconst undoRedoSelector = createShallowSelector((state: UndoRedoState) => ({\n  canUndo: (storeKey?: string) => state.canUndo(storeKey),\n  canRedo: (storeKey?: string) => state.canRedo(storeKey),\n  currentBranch: state.branches.get(state.currentBranchId)?.name || 'Unknown',\n  historySize: state.branches.get(state.currentBranchId)?.entries.length || 0,\n  currentIndex: state.currentIndex\n}));\n\n// Hooks\nexport const useUndoRedo = (storeKey?: string) => {\n  const selector = undoRedoSelector(useUndoRedoStore);\n  const actions = useUndoRedoStore((state) => ({\n    undo: () => state.undo(storeKey),\n    redo: () => state.redo(storeKey),\n    startGroup: state.startGroup,\n    endGroup: state.endGroup,\n    canUndo: selector.canUndo(storeKey),\n    canRedo: selector.canRedo(storeKey)\n  }));\n  \n  return actions;\n};\n\nexport const useUndoRedoActions = () => {\n  return useUndoRedoStore((state) => ({\n    registerStore: state.registerStore,\n    unregisterStore: state.unregisterStore,\n    createBranch: state.createBranch,\n    switchBranch: state.switchBranch,\n    deleteBranch: state.deleteBranch,\n    mergeBranch: state.mergeBranch,\n    clearHistory: state.clearHistory,\n    jumpToEntry: state.jumpToEntry\n  }));\n};\n\n// Auto-registration hook\nexport const useUndoRedoRegistration = (\n  storeKey: string,\n  useStore: any,\n  strategy: 'full' | 'selective' | 'none' = 'full',\n  selectiveProps?: string[]\n) => {\n  const { registerStore, unregisterStore } = useUndoRedoActions();\n  \n  React.useEffect(() => {\n    const storeInterface = {\n      getState: () => useStore.getState(),\n      setState: (state: any, actionName?: string) => {\n        useStore.setState(state, false, actionName);\n      },\n      subscribe: (callback: (state: any) => void) => {\n        return useStore.subscribe(callback);\n      }\n    };\n    \n    registerStore(storeKey, storeInterface, strategy);\n    \n    // Set selective props if provided\n    if (strategy === 'selective' && selectiveProps) {\n      useUndoRedoStore.setState((state) => ({\n        config: {\n          ...state.config,\n          selectiveProps: {\n            ...state.config.selectiveProps,\n            [storeKey]: selectiveProps\n          }\n        }\n      }));\n    }\n    \n    return () => unregisterStore(storeKey);\n  }, [storeKey, registerStore, unregisterStore, strategy, selectiveProps]);\n};\n\n// Keyboard shortcuts for undo/redo\nexport const useUndoRedoShortcuts = (storeKey?: string) => {\n  const { undo, redo } = useUndoRedo(storeKey);\n  \n  React.useEffect(() => {\n    const handleKeyDown = (event: KeyboardEvent) => {\n      if ((event.ctrlKey || event.metaKey) && !event.shiftKey && event.key === 'z') {\n        event.preventDefault();\n        undo();\n      } else if ((event.ctrlKey || event.metaKey) && (event.shiftKey && event.key === 'Z' || event.key === 'y')) {\n        event.preventDefault();\n        redo();\n      }\n    };\n    \n    if (typeof window !== 'undefined') {\n      window.addEventListener('keydown', handleKeyDown);\n      return () => window.removeEventListener('keydown', handleKeyDown);\n    }\n  }, [undo, redo]);\n};