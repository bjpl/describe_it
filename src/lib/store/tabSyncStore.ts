import React from 'react';
import { create } from 'zustand';
import { devtools, subscribeWithSelector } from 'zustand/middleware';
import { createShallowSelector } from '../utils/storeUtils';
import { safeParse, safeStringify } from "@/lib/utils/json-safe";
import { logger } from '@/lib/logger';

/**
 * Cross-Tab Synchronization Store
 * Features:
 * - BroadcastChannel API for modern browsers
 * - localStorage fallback for older browsers
 * - Real-time state synchronization
 * - Conflict resolution strategies
 * - Tab identity management
 * - Connection status tracking
 * - Selective synchronization
 */

export interface TabInfo {
  id: string;
  name: string;
  url: string;
  isActive: boolean;
  lastSeen: Date;
  capabilities: string[];
  version: string;
}

export interface SyncMessage {
  type: 'state-update' | 'heartbeat' | 'request-sync' | 'tab-join' | 'tab-leave';
  tabId: string;
  timestamp: Date;
  data?: any;
  storeKey?: string;
  conflictStrategy?: ConflictStrategy;
}

export type ConflictStrategy = 'last-write-wins' | 'merge' | 'manual' | 'ignore';

export interface SyncConfig {
  enabled: boolean;
  channel: string;
  heartbeatInterval: number;
  syncDebounceMs: number;
  conflictStrategy: ConflictStrategy;
  excludedStores: Set<string>;
  onConflict?: (local: any, remote: any, key: string) => any;
}

interface TabSyncState {
  // Tab management
  currentTabId: string;
  connectedTabs: Map<string, TabInfo>;
  isLeaderTab: boolean;
  connectionStatus: 'connected' | 'disconnected' | 'connecting';

  // Sync configuration
  config: SyncConfig;
  lastSyncTime: Date | null;
  syncErrors: string[];

  // Message handling
  messageQueue: SyncMessage[];
  pendingSync: Set<string>;

  // Actions
  initializeSync: (config?: Partial<SyncConfig>) => void;
  broadcastUpdate: (storeKey: string, data: any, strategy?: ConflictStrategy) => void;
  requestFullSync: () => void;
  registerStore: (storeKey: string, getState: () => any, setState: (state: any) => void) => void;
  unregisterStore: (storeKey: string) => void;
  setConflictStrategy: (strategy: ConflictStrategy) => void;
  excludeStore: (storeKey: string) => void;
  includeStore: (storeKey: string) => void;
  disconnect: () => void;

  // Internal methods
  _handleMessage: (message: SyncMessage) => void;
  _sendHeartbeat: () => void;
  _electLeader: () => void;
  _resolveConflict: (local: any, remote: any, key: string, strategy: ConflictStrategy) => any;
}

// Generate unique tab ID\nconst generateTabId = (): string => {\n  return `tab-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n};\n\n// Get tab info\nconst getTabInfo = (tabId: string): TabInfo => ({\n  id: tabId,\n  name: typeof document !== 'undefined' ? document.title : 'Unknown',\n  url: typeof window !== 'undefined' ? window.location.href : '',\n  isActive: typeof document !== 'undefined' ? !document.hidden : true,\n  lastSeen: new Date(),\n  capabilities: [\n    typeof BroadcastChannel !== 'undefined' ? 'broadcast-channel' : null,\n    typeof SharedWorker !== 'undefined' ? 'shared-worker' : null,\n    typeof ServiceWorker !== 'undefined' ? 'service-worker' : null\n  ].filter(Boolean),\n  version: '1.0.0'\n});\n\nconst defaultConfig: SyncConfig = {\n  enabled: true,\n  channel: 'describe-it-tab-sync',\n  heartbeatInterval: 5000,\n  syncDebounceMs: 100,\n  conflictStrategy: 'last-write-wins',\n  excludedStores: new Set(['ui-store']) // UI state typically shouldn't sync\n};\n\nexport const useTabSyncStore = create<TabSyncState>()(  \n  devtools(\n    subscribeWithSelector(\n      (set, get) => {\n        let broadcastChannel: BroadcastChannel | null = null;\n        let heartbeatInterval: NodeJS.Timeout | null = null;\n        let syncDebounceTimeout: NodeJS.Timeout | null = null;\n        const registeredStores = new Map<string, {\n          getState: () => any;\n          setState: (state: any) => void;\n        }>();\n        \n        return {\n          currentTabId: generateTabId(),\n          connectedTabs: new Map(),\n          isLeaderTab: false,\n          connectionStatus: 'disconnected',\n          config: defaultConfig,\n          lastSyncTime: null,\n          syncErrors: [],\n          messageQueue: [],\n          pendingSync: new Set(),\n          \n          initializeSync: (configOverrides = {}) => {\n            if (typeof window === 'undefined') return;\n            \n            const config = { ...defaultConfig, ...configOverrides };\n            set({ config, connectionStatus: 'connecting' }, false, 'initializeSync');\n            \n            try {\n              // Initialize BroadcastChannel if available\n              if (typeof BroadcastChannel !== 'undefined') {\n                broadcastChannel = new BroadcastChannel(config.channel);\n                \n                broadcastChannel.addEventListener('message', (event) => {\n                  get()._handleMessage(event.data);\n                });\n                \n                set({ connectionStatus: 'connected' }, false, 'broadcastChannel:connected');\n              } else {\n                // Fallback to localStorage events\n                const handleStorageChange = (event: StorageEvent) => {\n                  if (event.key === `${config.channel}-message` && event.newValue) {\n                    try {\n                      const message = safeParse(event.newValue);\n                      get()._handleMessage(message);\n                    } catch (error) {\n                      logger.warn('Failed to parse sync message:', error);\n                    }\n                  }\n                };\n                \n                window.addEventListener('storage', handleStorageChange);\n                set({ connectionStatus: 'connected' }, false, 'localStorage:connected');\n              }\n              \n              // Start heartbeat\n              heartbeatInterval = setInterval(() => {\n                get()._sendHeartbeat();\n              }, config.heartbeatInterval);\n              \n              // Elect leader\n              get()._electLeader();\n              \n              // Announce tab join\n              const tabInfo = getTabInfo(get().currentTabId);\n              set((state) => ({\n                connectedTabs: new Map(state.connectedTabs).set(state.currentTabId, tabInfo)\n              }), false, 'tab:join');\n              \n              get().broadcastUpdate('tab-join', tabInfo);\n              \n            } catch (error) {\n              logger.error('Failed to initialize tab sync:', error);\n              set({ \n                connectionStatus: 'disconnected',\n                syncErrors: [...get().syncErrors, error instanceof Error ? error.message : 'Unknown error']\n              }, false, 'initializeSync:error');\n            }\n          },\n          \n          broadcastUpdate: (storeKey, data, strategy = get().config.conflictStrategy) => {\n            if (!get().config.enabled || get().config.excludedStores.has(storeKey)) return;\n            \n            const message: SyncMessage = {\n              type: 'state-update',\n              tabId: get().currentTabId,\n              timestamp: new Date(),\n              storeKey,\n              data,\n              conflictStrategy: strategy\n            };\n            \n            // Debounce sync messages\n            if (syncDebounceTimeout) {\n              clearTimeout(syncDebounceTimeout);\n            }\n            \n            syncDebounceTimeout = setTimeout(() => {\n              if (broadcastChannel) {\n                broadcastChannel.postMessage(message);\n              } else {\n                // Fallback to localStorage\n                localStorage.setItem(\n                  `${get().config.channel}-message`,\n                  safeStringify(message)\n                );\n              }\n              \n              set({ lastSyncTime: new Date() }, false, 'broadcastUpdate');\n            }, get().config.syncDebounceMs);\n          },\n          \n          requestFullSync: () => {\n            const message: SyncMessage = {\n              type: 'request-sync',\n              tabId: get().currentTabId,\n              timestamp: new Date()\n            };\n            \n            if (broadcastChannel) {\n              broadcastChannel.postMessage(message);\n            }\n          },\n          \n          registerStore: (storeKey, getState, setState) => {\n            registeredStores.set(storeKey, { getState, setState });\n            \n            // Request initial sync for this store\n            if (get().connectionStatus === 'connected') {\n              setTimeout(() => {\n                get().broadcastUpdate('request-sync', { storeKey });\n              }, 100);\n            }\n          },\n          \n          unregisterStore: (storeKey) => {\n            registeredStores.delete(storeKey);\n            set((state) => {\n              const newPendingSync = new Set(state.pendingSync);\n              newPendingSync.delete(storeKey);\n              return { pendingSync: newPendingSync };\n            }, false, 'unregisterStore');\n          },\n          \n          setConflictStrategy: (strategy) => {\n            set((state) => ({\n              config: { ...state.config, conflictStrategy: strategy }\n            }), false, 'setConflictStrategy');\n          },\n          \n          excludeStore: (storeKey) => {\n            set((state) => ({\n              config: {\n                ...state.config,\n                excludedStores: new Set(state.config.excludedStores).add(storeKey)\n              }\n            }), false, 'excludeStore');\n          },\n          \n          includeStore: (storeKey) => {\n            set((state) => {\n              const newExcludedStores = new Set(state.config.excludedStores);\n              newExcludedStores.delete(storeKey);\n              return {\n                config: { ...state.config, excludedStores: newExcludedStores }\n              };\n            }, false, 'includeStore');\n          },\n          \n          disconnect: () => {\n            if (broadcastChannel) {\n              broadcastChannel.close();\n              broadcastChannel = null;\n            }\n            \n            if (heartbeatInterval) {\n              clearInterval(heartbeatInterval);\n              heartbeatInterval = null;\n            }\n            \n            if (syncDebounceTimeout) {\n              clearTimeout(syncDebounceTimeout);\n              syncDebounceTimeout = null;\n            }\n            \n            // Announce tab leave\n            get().broadcastUpdate('tab-leave', { tabId: get().currentTabId });\n            \n            set({ \n              connectionStatus: 'disconnected',\n              connectedTabs: new Map(),\n              isLeaderTab: false\n            }, false, 'disconnect');\n          },\n          \n          _handleMessage: (message: SyncMessage) => {\n            const state = get();\n            \n            // Ignore messages from self\n            if (message.tabId === state.currentTabId) return;\n            \n            switch (message.type) {\n              case 'state-update': {\n                if (!message.storeKey || !message.data) break;\n                \n                const store = registeredStores.get(message.storeKey);\n                if (!store) break;\n                \n                try {\n                  const currentState = store.getState();\n                  const resolvedState = get()._resolveConflict(\n                    currentState,\n                    message.data,\n                    message.storeKey,\n                    message.conflictStrategy || 'last-write-wins'\n                  );\n                  \n                  store.setState(resolvedState);\n                  \n                  set({ lastSyncTime: new Date() }, false, 'state-update:received');\n                } catch (error) {\n                  logger.error(`Failed to apply sync update for ${message.storeKey}:`, error);\n                  set((state) => ({\n                    syncErrors: [...state.syncErrors, `Sync error: ${error instanceof Error ? error.message : 'Unknown'}`]\n                  }), false, 'state-update:error');\n                }\n                break;\n              }\n              \n              case 'heartbeat': {\n                // Update connected tabs info\n                set((state) => {\n                  const newConnectedTabs = new Map(state.connectedTabs);\n                  const existingTab = newConnectedTabs.get(message.tabId);\n                  \n                  newConnectedTabs.set(message.tabId, {\n                    ...existingTab,\n                    ...message.data,\n                    id: message.tabId,\n                    lastSeen: message.timestamp\n                  });\n                  \n                  return { connectedTabs: newConnectedTabs };\n                }, false, 'heartbeat:received');\n                break;\n              }\n              \n              case 'request-sync': {\n                // Send current state to requesting tab\n                if (state.isLeaderTab) {\n                  registeredStores.forEach((store, storeKey) => {\n                    if (!state.config.excludedStores.has(storeKey)) {\n                      get().broadcastUpdate(storeKey, store.getState());\n                    }\n                  });\n                }\n                break;\n              }\n              \n              case 'tab-join': {\n                set((state) => {\n                  const newConnectedTabs = new Map(state.connectedTabs);\n                  newConnectedTabs.set(message.tabId, message.data);\n                  return { connectedTabs: newConnectedTabs };\n                }, false, 'tab:join');\n                \n                // Re-elect leader if needed\n                get()._electLeader();\n                break;\n              }\n              \n              case 'tab-leave': {\n                set((state) => {\n                  const newConnectedTabs = new Map(state.connectedTabs);\n                  newConnectedTabs.delete(message.tabId);\n                  return { connectedTabs: newConnectedTabs };\n                }, false, 'tab:leave');\n                \n                get()._electLeader();\n                break;\n              }\n            }\n          },\n          \n          _sendHeartbeat: () => {\n            const tabInfo = getTabInfo(get().currentTabId);\n            \n            const message: SyncMessage = {\n              type: 'heartbeat',\n              tabId: get().currentTabId,\n              timestamp: new Date(),\n              data: tabInfo\n            };\n            \n            if (broadcastChannel) {\n              broadcastChannel.postMessage(message);\n            }\n          },\n          \n          _electLeader: () => {\n            const state = get();\n            const connectedTabIds = Array.from(state.connectedTabs.keys());\n            connectedTabIds.push(state.currentTabId);\n            \n            // Elect the tab with the earliest ID (timestamp-based)\n            const leaderId = connectedTabIds.sort()[0];\n            const isLeader = leaderId === state.currentTabId;\n            \n            if (isLeader !== state.isLeaderTab) {\n              set({ isLeaderTab: isLeader }, false, 'leader:elected');\n            }\n          },\n          \n          _resolveConflict: (local, remote, key, strategy) => {\n            switch (strategy) {\n              case 'last-write-wins':\n                return remote;\n              \n              case 'merge':\n                if (typeof local === 'object' && typeof remote === 'object' && local !== null && remote !== null) {\n                  return { ...local, ...remote };\n                }\n                return remote;\n              \n              case 'manual':\n                // Call custom conflict resolver if provided\n                if (get().config.onConflict) {\n                  return get().config.onConflict!(local, remote, key);\n                }\n                return local; // Keep local if no resolver\n              \n              case 'ignore':\n              default:\n                return local;\n            }\n          }\n        };\n      }\n    ),\n    { name: 'TabSyncStore' }\n  )\n);\n\n// Hooks\nexport const useTabSync = () => {\n  return useTabSyncStore((state) => ({\n    currentTabId: state.currentTabId,\n    connectedTabs: Array.from(state.connectedTabs.values()),\n    isLeaderTab: state.isLeaderTab,\n    connectionStatus: state.connectionStatus,\n    lastSyncTime: state.lastSyncTime,\n    syncErrors: state.syncErrors\n  }));\n};\n\nexport const useTabSyncActions = () => {\n  return useTabSyncStore((state) => ({\n    initializeSync: state.initializeSync,\n    broadcastUpdate: state.broadcastUpdate,\n    requestFullSync: state.requestFullSync,\n    registerStore: state.registerStore,\n    unregisterStore: state.unregisterStore,\n    setConflictStrategy: state.setConflictStrategy,\n    excludeStore: state.excludeStore,\n    includeStore: state.includeStore,\n    disconnect: state.disconnect\n  }));\n};\n\n// Store sync registration hook\nexport const useStoreSyncRegistration = (\n  storeKey: string,\n  useStore: any,\n  enabled = true\n) => {\n  const { registerStore, unregisterStore } = useTabSyncActions();\n  \n  React.useEffect(() => {\n    if (!enabled) return;\n    \n    const getState = () => useStore.getState();\n    const setState = (state: any) => useStore.setState(state, false, `sync:${storeKey}`);\n    \n    registerStore(storeKey, getState, setState);\n    \n    return () => unregisterStore(storeKey);\n  }, [storeKey, useStore, registerStore, unregisterStore, enabled]);\n};\n\n// Auto-initialize hook\nexport const useAutoTabSync = (config?: Partial<SyncConfig>) => {\n  const { initializeSync, disconnect } = useTabSyncActions();\n  \n  React.useEffect(() => {\n    initializeSync(config);\n    \n    // Cleanup on unmount\n    return () => {\n      disconnect();\n    };\n  }, [initializeSync, disconnect]);\n};