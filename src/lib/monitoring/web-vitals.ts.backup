import { getCLS, getFID, getFCP, getLCP, getTTFB, Metric } from 'web-vitals';

// Web Vitals monitoring and performance tracking
export interface WebVitalsData {
  name: string;
  value: number;
  id: string;
  timestamp: number;
  url: string;
  userAgent: string;
  connectionType?: string;
  isFirstVisit: boolean;
  sessionId: string;
}

// Performance thresholds based on Google's recommendations
export const PERFORMANCE_THRESHOLDS = {
  CLS: {
    good: 0.1,
    poor: 0.25
  },
  FID: {
    good: 100,
    poor: 300
  },
  FCP: {
    good: 1800,
    poor: 3000
  },
  LCP: {
    good: 2500,
    poor: 4000
  },
  TTFB: {
    good: 800,
    poor: 1800
  }
} as const;

// Session storage key for tracking visits
const SESSION_KEY = 'web-vitals-session';
const FIRST_VISIT_KEY = 'web-vitals-first-visit';

class WebVitalsMonitor {
  private sessionId: string;
  private isFirstVisit: boolean;
  private metricsCollected: Set<string> = new Set();

  constructor() {
    this.sessionId = this.generateSessionId();
    this.isFirstVisit = this.checkFirstVisit();
    this.setupErrorTracking();
  }

  /**
   * Initialize web vitals monitoring
   */
  public init(): void {
    if (typeof window === 'undefined') {
      console.warn('Web vitals can only be monitored in the browser');
      return;
    }

    // Collect all Core Web Vitals
    getCLS(this.onMetric.bind(this));
    getFID(this.onMetric.bind(this));
    getFCP(this.onMetric.bind(this));
    getLCP(this.onMetric.bind(this));
    getTTFB(this.onMetric.bind(this));

    // Track page visibility changes for more accurate metrics
    this.trackVisibilityChanges();

    // Track network information if available
    this.trackNetworkInfo();

    console.log(`Web vitals monitoring initialized for session: ${this.sessionId}`);
  }

  /**
   * Handle metric collection
   */
  private onMetric(metric: Metric): void {
    // Avoid duplicate reporting
    if (this.metricsCollected.has(`${metric.name}-${metric.id}`)) {
      return;
    }

    this.metricsCollected.add(`${metric.name}-${metric.id}`);

    const webVitalData: WebVitalsData = {
      name: metric.name,
      value: metric.value,
      id: metric.id,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      connectionType: this.getConnectionType(),
      isFirstVisit: this.isFirstVisit,
      sessionId: this.sessionId
    };

    // Log metric with performance rating
    const rating = this.getRating(metric.name, metric.value);
    console.log(`üìä ${metric.name}: ${metric.value.toFixed(2)} (${rating})`, {
      metric: webVitalData,
      rating,
      threshold: PERFORMANCE_THRESHOLDS[metric.name as keyof typeof PERFORMANCE_THRESHOLDS]
    });

    // Send to analytics
    this.sendToAnalytics(webVitalData, rating);

    // Store locally for debugging
    this.storeMetricLocally(webVitalData, rating);

    // Trigger custom events
    this.dispatchMetricEvent(webVitalData, rating);
  }

  /**
   * Get performance rating based on thresholds
   */
  private getRating(metricName: string, value: number): 'good' | 'needs-improvement' | 'poor' {
    const threshold = PERFORMANCE_THRESHOLDS[metricName as keyof typeof PERFORMANCE_THRESHOLDS];
    
    if (!threshold) {
      return 'good'; // Default for unknown metrics
    }

    if (value <= threshold.good) {
      return 'good';
    } else if (value <= threshold.poor) {
      return 'needs-improvement';
    } else {
      return 'poor';
    }
  }

  /**
   * Send metrics to analytics service
   */
  private async sendToAnalytics(data: WebVitalsData, rating: string): Promise<void> {
    try {
      // Send to internal analytics API
      await fetch('/api/analytics/web-vitals', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ ...data, rating }),
        keepalive: true // Ensure data is sent even if page is unloading
      });

      // Send to Vercel Analytics if available
      if (typeof window.va !== 'undefined') {
        window.va('track', 'Web Vital', {
          metric: data.name,
          value: data.value,
          rating,
          sessionId: data.sessionId
        });
      }

      // Send to Google Analytics if available
      if (typeof window.gtag !== 'undefined') {
        window.gtag('event', data.name, {
          value: Math.round(data.value),
          metric_rating: rating,
          custom_parameter_1: data.sessionId,
          custom_parameter_2: data.isFirstVisit ? 'first_visit' : 'return_visit'
        });
      }
    } catch (error) {
      console.error('Failed to send web vitals to analytics:', error);
    }
  }

  /**
   * Store metric locally for debugging
   */
  private storeMetricLocally(data: WebVitalsData, rating: string): void {
    try {
      const key = `web-vitals-${this.sessionId}`;
      const existing = localStorage.getItem(key);
      const metrics = existing ? JSON.parse(existing) : [];
      
      metrics.push({ ...data, rating, collectedAt: new Date().toISOString() });
      
      // Keep only last 50 metrics to avoid storage bloat
      const trimmed = metrics.slice(-50);
      
      localStorage.setItem(key, JSON.stringify(trimmed));
    } catch (error) {
      console.warn('Failed to store web vitals locally:', error);
    }
  }

  /**
   * Dispatch custom event for metric collection
   */
  private dispatchMetricEvent(data: WebVitalsData, rating: string): void {
    try {
      const event = new CustomEvent('webvital', {
        detail: { ...data, rating }
      });
      window.dispatchEvent(event);
    } catch (error) {
      console.warn('Failed to dispatch web vital event:', error);
    }
  }

  /**
   * Generate unique session ID
   */
  private generateSessionId(): string {
    const stored = sessionStorage.getItem(SESSION_KEY);
    if (stored) {
      return stored;
    }

    const sessionId = `wv_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    sessionStorage.setItem(SESSION_KEY, sessionId);
    return sessionId;
  }

  /**
   * Check if this is the first visit
   */
  private checkFirstVisit(): boolean {
    const hasVisited = localStorage.getItem(FIRST_VISIT_KEY);
    if (!hasVisited) {
      localStorage.setItem(FIRST_VISIT_KEY, 'true');
      return true;
    }
    return false;
  }

  /**
   * Get connection type if available
   */
  private getConnectionType(): string | undefined {
    const connection = (navigator as any).connection || 
                     (navigator as any).mozConnection || 
                     (navigator as any).webkitConnection;
    
    return connection?.effectiveType || connection?.type;
  }

  /**
   * Track page visibility changes
   */
  private trackVisibilityChanges(): void {
    let startTime = Date.now();

    const handleVisibilityChange = () => {
      if (document.hidden) {
        const timeVisible = Date.now() - startTime;
        console.log(`üìÑ Page was visible for ${timeVisible}ms`);
        
        // Track page visibility time
        this.trackCustomMetric('page_visibility_duration', timeVisible);
      } else {
        startTime = Date.now();
      }
    };

    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  /**
   * Track network information
   */
  private trackNetworkInfo(): void {
    const connection = this.getConnectionType();
    if (connection) {
      console.log(`üåê Connection type: ${connection}`);
      this.trackCustomMetric('connection_type', 0, { connectionType: connection });
    }
  }

  /**
   * Track custom performance metrics
   */
  public trackCustomMetric(name: string, value: number, metadata?: Record<string, any>): void {
    const customMetric: WebVitalsData & { metadata?: Record<string, any> } = {
      name: `custom_${name}`,
      value,
      id: `${name}_${Date.now()}`,
      timestamp: Date.now(),
      url: window.location.href,
      userAgent: navigator.userAgent,
      connectionType: this.getConnectionType(),
      isFirstVisit: this.isFirstVisit,
      sessionId: this.sessionId,
      metadata
    };

    console.log(`üìã Custom metric ${name}: ${value}`, customMetric);

    // Send to analytics
    this.sendToAnalytics(customMetric, 'custom');
  }

  /**
   * Track resource loading times
   */
  public trackResourceTiming(): void {
    if (!window.performance || !window.performance.getEntriesByType) {
      return;
    }

    const resources = window.performance.getEntriesByType('resource') as PerformanceResourceTiming[];
    
    resources.forEach(resource => {
      if (resource.duration > 0) {
        this.trackCustomMetric(`resource_load_${this.getResourceType(resource.name)}`, resource.duration, {
          resourceUrl: resource.name,
          transferSize: resource.transferSize,
          encodedBodySize: resource.encodedBodySize,
          decodedBodySize: resource.decodedBodySize
        });
      }
    });
  }

  /**
   * Get resource type from URL
   */
  private getResourceType(url: string): string {
    if (url.match(/\.(js|mjs)(\?|$)/)) return 'javascript';
    if (url.match(/\.(css)(\?|$)/)) return 'stylesheet';
    if (url.match(/\.(jpg|jpeg|png|gif|svg|webp)(\?|$)/)) return 'image';
    if (url.match(/\.(woff|woff2|ttf|otf)(\?|$)/)) return 'font';
    if (url.includes('/api/')) return 'api';
    return 'other';
  }

  /**
   * Setup global error tracking
   */
  private setupErrorTracking(): void {
    // Track JavaScript errors
    window.addEventListener('error', (event) => {
      this.trackCustomMetric('javascript_error', 1, {
        error: event.error?.message || 'Unknown error',
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        stack: event.error?.stack
      });
    });

    // Track unhandled promise rejections
    window.addEventListener('unhandledrejection', (event) => {
      this.trackCustomMetric('unhandled_rejection', 1, {
        reason: event.reason?.toString() || 'Unknown rejection',
        promise: event.promise
      });
    });
  }

  /**
   * Get current session metrics summary
   */
  public getSessionSummary(): Record<string, any> {
    try {
      const key = `web-vitals-${this.sessionId}`;
      const stored = localStorage.getItem(key);
      if (!stored) return {};

      const metrics = JSON.parse(stored);
      const summary: Record<string, any> = {
        sessionId: this.sessionId,
        isFirstVisit: this.isFirstVisit,
        totalMetrics: metrics.length,
        connectionType: this.getConnectionType(),
        url: window.location.href,
        userAgent: navigator.userAgent.substring(0, 100) + '...'
      };

      // Aggregate core web vitals
      const coreVitals = ['CLS', 'FID', 'FCP', 'LCP', 'TTFB'];
      coreVitals.forEach(vital => {
        const metric = metrics.find((m: any) => m.name === vital);
        if (metric) {
          summary[vital.toLowerCase()] = {
            value: metric.value,
            rating: metric.rating,
            timestamp: metric.timestamp
          };
        }
      });

      return summary;
    } catch (error) {
      console.error('Failed to get session summary:', error);
      return {};
    }
  }

  /**
   * Export all metrics for debugging
   */
  public exportMetrics(): void {
    const summary = this.getSessionSummary();
    const blob = new Blob([JSON.stringify(summary, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `web-vitals-${this.sessionId}.json`;
    a.click();
    URL.revokeObjectURL(url);
  }
}

// Global instance
export const webVitalsMonitor = new WebVitalsMonitor();

// Auto-initialize in browser environment
if (typeof window !== 'undefined') {
  // Initialize when DOM is ready
  if (document.readyState === 'complete') {
    webVitalsMonitor.init();
  } else {
    window.addEventListener('load', () => webVitalsMonitor.init());
  }
}

// Export utilities
export { WebVitalsMonitor };

// Extend window interface for analytics
declare global {
  interface Window {
    va?: (event: string, data?: Record<string, any>) => void;
    gtag?: (...args: any[]) => void;
  }
}

// React hook for web vitals
export function useWebVitals() {
  const trackMetric = (name: string, value: number, metadata?: Record<string, any>) => {
    webVitalsMonitor.trackCustomMetric(name, value, metadata);
  };

  const getSessionSummary = () => {
    return webVitalsMonitor.getSessionSummary();
  };

  const exportMetrics = () => {
    webVitalsMonitor.exportMetrics();
  };

  return {
    trackMetric,
    getSessionSummary,
    exportMetrics
  };
}

// Performance monitoring utilities
export const performanceUtils = {
  /**
   * Measure function execution time
   */
  measureAsync: async <T>(name: string, fn: () => Promise<T>): Promise<T> => {
    const start = performance.now();
    try {
      const result = await fn();
      const duration = performance.now() - start;
      webVitalsMonitor.trackCustomMetric(`function_${name}`, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      webVitalsMonitor.trackCustomMetric(`function_${name}_error`, duration);
      throw error;
    }
  },

  /**
   * Measure sync function execution time
   */
  measureSync: <T>(name: string, fn: () => T): T => {
    const start = performance.now();
    try {
      const result = fn();
      const duration = performance.now() - start;
      webVitalsMonitor.trackCustomMetric(`function_${name}`, duration);
      return result;
    } catch (error) {
      const duration = performance.now() - start;
      webVitalsMonitor.trackCustomMetric(`function_${name}_error`, duration);
      throw error;
    }
  },

  /**
   * Mark performance milestone
   */
  mark: (name: string) => {
    if (performance.mark) {
      performance.mark(name);
      console.log(`‚è±Ô∏è Performance mark: ${name} at ${Date.now()}`);
    }
  },

  /**
   * Measure time between marks
   */
  measureBetweenMarks: (name: string, startMark: string, endMark: string) => {
    if (performance.measure) {
      performance.measure(name, startMark, endMark);
      const entries = performance.getEntriesByName(name, 'measure');
      if (entries.length > 0) {
        const duration = entries[entries.length - 1].duration;
        webVitalsMonitor.trackCustomMetric(`measure_${name}`, duration);
        console.log(`üìè Performance measure ${name}: ${duration.toFixed(2)}ms`);
      }
    }
  }
};

// Component performance profiler for React
export function withPerformanceTracking<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  componentName: string
) {
  return function PerformanceTrackedComponent(props: P) {
    React.useEffect(() => {
      const renderStart = performance.now();
      
      return () => {
        const renderTime = performance.now() - renderStart;
        webVitalsMonitor.trackCustomMetric(`component_render_${componentName}`, renderTime);
      };
    }, []);

    return React.createElement(WrappedComponent, props);
  };
}