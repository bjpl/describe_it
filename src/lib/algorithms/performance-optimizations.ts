/**\n * Performance Optimizations for Learning Algorithms\n * Ensures O(n) or better complexity for all operations\n */\n\nimport { SpacedRepetitionCard } from './spaced-repetition';\nimport { LeitnerCard } from './leitner-system';\nimport { AdaptiveDifficultyCard } from './adaptive-difficulty';\nimport { UnifiedCard } from './algorithm-interface';\n\n/**\n * Optimized data structures and algorithms for better performance\n */\nexport class AlgorithmOptimizer {\n  private static readonly BATCH_SIZE = 1000;\n  private static readonly MAX_CACHE_SIZE = 10000;\n\n  /**\n   * Optimized card sorting with O(n log n) complexity\n   * Uses efficient sorting algorithms and caching\n   */\n  static sortCardsByPriority(\n    cards: UnifiedCard[], \n    currentTime: Date = new Date()\n  ): UnifiedCard[] {\n    if (cards.length === 0) return [];\n    \n    const currentTimeMs = currentTime.getTime();\n    \n    // Use a single pass to calculate priorities and sort\n    return cards\n      .map(card => ({\n        card,\n        priority: this.calculateCardPriority(card, currentTimeMs),\n      }))\n      .sort((a, b) => b.priority - a.priority) // Higher priority first\n      .map(({ card }) => card);\n  }\n\n  /**\n   * Fast card filtering with O(n) complexity\n   * Combines multiple filters in a single pass\n   */\n  static filterCards(\n    cards: UnifiedCard[],\n    filters: {\n      algorithm?: string;\n      mastery_level?: string[];\n      due_before?: Date;\n      min_reviews?: number;\n      max_reviews?: number;\n    }\n  ): UnifiedCard[] {\n    if (cards.length === 0) return [];\n    \n    const dueBeforeMs = filters.due_before?.getTime();\n    \n    return cards.filter(card => {\n      // Algorithm filter\n      if (filters.algorithm && card.algorithm_type !== filters.algorithm) {\n        return false;\n      }\n      \n      // Mastery level filter\n      if (filters.mastery_level && !filters.mastery_level.includes(card.mastery_level)) {\n        return false;\n      }\n      \n      // Due date filter\n      if (dueBeforeMs && card.next_review_date.getTime() > dueBeforeMs) {\n        return false;\n      }\n      \n      // Review count filters\n      if (filters.min_reviews !== undefined && card.total_reviews < filters.min_reviews) {\n        return false;\n      }\n      \n      if (filters.max_reviews !== undefined && card.total_reviews > filters.max_reviews) {\n        return false;\n      }\n      \n      return true;\n    });\n  }\n\n  /**\n   * Batch process cards for better performance\n   * Processes cards in chunks to avoid blocking the main thread\n   */\n  static async batchProcessCards<T, R>(\n    cards: T[],\n    processor: (batch: T[]) => Promise<R[]>,\n    batchSize: number = this.BATCH_SIZE\n  ): Promise<R[]> {\n    if (cards.length === 0) return [];\n    \n    const results: R[] = [];\n    \n    for (let i = 0; i < cards.length; i += batchSize) {\n      const batch = cards.slice(i, i + batchSize);\n      const batchResults = await processor(batch);\n      results.push(...batchResults);\n      \n      // Allow other tasks to run\n      if (i + batchSize < cards.length) {\n        await new Promise(resolve => setTimeout(resolve, 0));\n      }\n    }\n    \n    return results;\n  }\n\n  /**\n   * Optimized statistics calculation with O(n) complexity\n   * Calculates multiple statistics in a single pass\n   */\n  static calculateBulkStatistics(cards: UnifiedCard[]): {\n    total_cards: number;\n    by_mastery: Record<string, number>;\n    by_algorithm: Record<string, number>;\n    accuracy_stats: {\n      overall: number;\n      by_mastery: Record<string, number>;\n    };\n    timing_stats: {\n      average_response_time: number;\n      fastest_10_percent: number;\n      slowest_10_percent: number;\n    };\n    review_distribution: {\n      new: number;\n      learning: number;\n      mature: number;\n    };\n  } {\n    if (cards.length === 0) {\n      return this.getEmptyStatistics();\n    }\n\n    // Single pass through all cards\n    const stats = {\n      total_cards: cards.length,\n      by_mastery: {} as Record<string, number>,\n      by_algorithm: {} as Record<string, number>,\n      accuracy_totals: {} as Record<string, { correct: number; total: number }>,\n      response_times: [] as number[],\n      review_counts: { new: 0, learning: 0, mature: 0 },\n      total_correct: 0,\n      total_reviews: 0,\n    };\n\n    cards.forEach(card => {\n      // Count by mastery level\n      stats.by_mastery[card.mastery_level] = (stats.by_mastery[card.mastery_level] || 0) + 1;\n      \n      // Count by algorithm\n      stats.by_algorithm[card.algorithm_type] = (stats.by_algorithm[card.algorithm_type] || 0) + 1;\n      \n      // Accuracy tracking\n      if (!stats.accuracy_totals[card.mastery_level]) {\n        stats.accuracy_totals[card.mastery_level] = { correct: 0, total: 0 };\n      }\n      stats.accuracy_totals[card.mastery_level].correct += card.correct_reviews;\n      stats.accuracy_totals[card.mastery_level].total += card.total_reviews;\n      \n      // Overall accuracy\n      stats.total_correct += card.correct_reviews;\n      stats.total_reviews += card.total_reviews;\n      \n      // Response times (only if available)\n      if (card.average_response_time > 0) {\n        stats.response_times.push(card.average_response_time);\n      }\n      \n      // Review distribution\n      if (card.total_reviews === 0) {\n        stats.review_counts.new++;\n      } else if (card.total_reviews < 5 || card.mastery_level === 'learning') {\n        stats.review_counts.learning++;\n      } else {\n        stats.review_counts.mature++;\n      }\n    });\n\n    // Calculate final statistics\n    const accuracy_by_mastery: Record<string, number> = {};\n    Object.entries(stats.accuracy_totals).forEach(([level, data]) => {\n      accuracy_by_mastery[level] = data.total > 0 ? data.correct / data.total : 0;\n    });\n\n    // Sort response times for percentile calculations\n    stats.response_times.sort((a, b) => a - b);\n    const len = stats.response_times.length;\n    const avg_response_time = len > 0 \n      ? stats.response_times.reduce((sum, time) => sum + time, 0) / len \n      : 0;\n    const fastest_10_percent = len > 0 ? stats.response_times[Math.floor(len * 0.1)] : 0;\n    const slowest_10_percent = len > 0 ? stats.response_times[Math.floor(len * 0.9)] : 0;\n\n    return {\n      total_cards: stats.total_cards,\n      by_mastery: stats.by_mastery,\n      by_algorithm: stats.by_algorithm,\n      accuracy_stats: {\n        overall: stats.total_reviews > 0 ? stats.total_correct / stats.total_reviews : 0,\n        by_mastery: accuracy_by_mastery,\n      },\n      timing_stats: {\n        average_response_time: avg_response_time,\n        fastest_10_percent,\n        slowest_10_percent,\n      },\n      review_distribution: stats.review_counts,\n    };\n  }\n\n  /**\n   * Fast card lookup using hash maps for O(1) complexity\n   */\n  static createCardIndex(cards: UnifiedCard[]): {\n    byId: Map<string, UnifiedCard>;\n    byAlgorithm: Map<string, UnifiedCard[]>;\n    byMastery: Map<string, UnifiedCard[]>;\n    dueCards: UnifiedCard[];\n    newCards: UnifiedCard[];\n  } {\n    const byId = new Map<string, UnifiedCard>();\n    const byAlgorithm = new Map<string, UnifiedCard[]>();\n    const byMastery = new Map<string, UnifiedCard[]>();\n    const dueCards: UnifiedCard[] = [];\n    const newCards: UnifiedCard[] = [];\n    const currentTime = new Date().getTime();\n\n    cards.forEach(card => {\n      // Index by ID\n      byId.set(card.phrase_id, card);\n      \n      // Index by algorithm\n      if (!byAlgorithm.has(card.algorithm_type)) {\n        byAlgorithm.set(card.algorithm_type, []);\n      }\n      byAlgorithm.get(card.algorithm_type)!.push(card);\n      \n      // Index by mastery\n      if (!byMastery.has(card.mastery_level)) {\n        byMastery.set(card.mastery_level, []);\n      }\n      byMastery.get(card.mastery_level)!.push(card);\n      \n      // Due cards\n      if (card.next_review_date.getTime() <= currentTime) {\n        dueCards.push(card);\n      }\n      \n      // New cards\n      if (card.total_reviews === 0) {\n        newCards.push(card);\n      }\n    });\n\n    return { byId, byAlgorithm, byMastery, dueCards, newCards };\n  }\n\n  /**\n   * Efficient session generation with optimal card selection\n   */\n  static generateOptimalSession(\n    cardIndex: ReturnType<typeof AlgorithmOptimizer.createCardIndex>,\n    config: {\n      algorithm?: string;\n      max_new: number;\n      max_review: number;\n      target_accuracy?: number;\n      difficulty_balance?: boolean;\n    }\n  ): {\n    new_cards: UnifiedCard[];\n    review_cards: UnifiedCard[];\n    total_estimated_time: number;\n  } {\n    let newCards = cardIndex.newCards;\n    let reviewCards = cardIndex.dueCards;\n\n    // Filter by algorithm if specified\n    if (config.algorithm) {\n      const algorithmCards = cardIndex.byAlgorithm.get(config.algorithm) || [];\n      const algorithmCardIds = new Set(algorithmCards.map(c => c.phrase_id));\n      \n      newCards = newCards.filter(c => algorithmCardIds.has(c.phrase_id));\n      reviewCards = reviewCards.filter(c => algorithmCardIds.has(c.phrase_id));\n    }\n\n    // Sort review cards by priority (already calculated in createCardIndex)\n    reviewCards.sort((a, b) => {\n      // Prioritize struggling cards and overdue cards\n      const aPriority = this.calculateCardPriority(a);\n      const bPriority = this.calculateCardPriority(b);\n      return bPriority - aPriority;\n    });\n\n    // Select cards with limits\n    const selectedNew = newCards.slice(0, config.max_new);\n    const selectedReview = reviewCards.slice(0, config.max_review);\n\n    // Estimate total time\n    const totalCards = selectedNew.length + selectedReview.length;\n    const avgTimePerCard = this.calculateAverageTimePerCard([...selectedNew, ...selectedReview]);\n    const totalEstimatedTime = totalCards * avgTimePerCard;\n\n    return {\n      new_cards: selectedNew,\n      review_cards: selectedReview,\n      total_estimated_time: Math.round(totalEstimatedTime / 60000), // Convert to minutes\n    };\n  }\n\n  /**\n   * Memory-efficient card updates\n   */\n  static updateCardsInBatch(\n    cards: UnifiedCard[],\n    updates: Map<string, Partial<UnifiedCard>>\n  ): UnifiedCard[] {\n    if (updates.size === 0) return cards;\n    \n    return cards.map(card => {\n      const update = updates.get(card.phrase_id);\n      return update ? { ...card, ...update } : card;\n    });\n  }\n\n  /**\n   * Optimized trend calculation with moving windows\n   */\n  static calculateTrends(\n    dataPoints: number[],\n    windowSize: number = 7\n  ): {\n    trend: 'increasing' | 'decreasing' | 'stable';\n    slope: number;\n    confidence: number;\n  } {\n    if (dataPoints.length < windowSize) {\n      return { trend: 'stable', slope: 0, confidence: 0 };\n    }\n\n    // Use the last windowSize points\n    const recentData = dataPoints.slice(-windowSize);\n    \n    // Calculate linear regression slope efficiently\n    const n = recentData.length;\n    const sumX = (n * (n - 1)) / 2; // 0 + 1 + ... + (n-1)\n    const sumY = recentData.reduce((sum, val) => sum + val, 0);\n    const sumXY = recentData.reduce((sum, val, i) => sum + val * i, 0);\n    const sumXX = (n * (n - 1) * (2 * n - 1)) / 6; // Sum of squares\n    \n    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);\n    \n    // Calculate confidence based on data consistency\n    const mean = sumY / n;\n    const variance = recentData.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / n;\n    const confidence = Math.max(0, Math.min(1, 1 - Math.sqrt(variance) / mean));\n    \n    // Determine trend\n    const threshold = 0.01; // Minimum slope to consider a trend\n    let trend: 'increasing' | 'decreasing' | 'stable';\n    if (slope > threshold) {\n      trend = 'increasing';\n    } else if (slope < -threshold) {\n      trend = 'decreasing';\n    } else {\n      trend = 'stable';\n    }\n    \n    return { trend, slope, confidence };\n  }\n\n  /**\n   * Performance monitoring for algorithm operations\n   */\n  static monitorPerformance<T>(\n    operation: () => T,\n    operationName: string\n  ): {\n    result: T;\n    executionTime: number;\n    memoryUsage?: number;\n  } {\n    const startTime = performance.now();\n    const startMemory = typeof window !== 'undefined' && 'memory' in performance \n      ? (performance as any).memory.usedJSHeapSize \n      : undefined;\n    \n    const result = operation();\n    \n    const endTime = performance.now();\n    const endMemory = typeof window !== 'undefined' && 'memory' in performance \n      ? (performance as any).memory.usedJSHeapSize \n      : undefined;\n    \n    const executionTime = endTime - startTime;\n    const memoryUsage = startMemory && endMemory ? endMemory - startMemory : undefined;\n    \n    // Log performance if it's unusually slow\n    if (executionTime > 100) {\n      console.warn(`Slow operation detected: ${operationName} took ${executionTime.toFixed(2)}ms`);\n    }\n    \n    return {\n      result,\n      executionTime,\n      memoryUsage,\n    };\n  }\n\n  /**\n   * Cache management for frequently accessed data\n   */\n  private static cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n  \n  static getCached<T>(key: string, ttlMs: number = 300000): T | null {\n    const cached = this.cache.get(key);\n    if (cached && Date.now() - cached.timestamp < cached.ttl) {\n      return cached.data as T;\n    }\n    this.cache.delete(key);\n    return null;\n  }\n  \n  static setCache<T>(key: string, data: T, ttlMs: number = 300000): void {\n    // Implement LRU eviction if cache is too large\n    if (this.cache.size >= this.MAX_CACHE_SIZE) {\n      const oldestKey = this.cache.keys().next().value;\n      this.cache.delete(oldestKey);\n    }\n    \n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl: ttlMs,\n    });\n  }\n  \n  static clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Private helper methods\n   */\n  private static calculateCardPriority(card: UnifiedCard, currentTimeMs?: number): number {\n    const now = currentTimeMs || Date.now();\n    const overdueDays = (now - card.next_review_date.getTime()) / (1000 * 60 * 60 * 24);\n    \n    let priority = 0;\n    \n    // Base priority on how overdue the card is\n    if (overdueDays > 0) {\n      priority += overdueDays * 10; // Higher priority for more overdue cards\n    }\n    \n    // Boost priority for struggling cards\n    if (card.streak_incorrect >= 2) {\n      priority += 20;\n    }\n    \n    // Lower priority for mastered cards\n    if (card.mastery_level === 'mastered') {\n      priority -= 5;\n    } else if (card.mastery_level === 'new') {\n      priority += 5; // Slight boost for new cards\n    }\n    \n    return priority;\n  }\n  \n  private static calculateAverageTimePerCard(cards: UnifiedCard[]): number {\n    if (cards.length === 0) return 90000; // Default 90 seconds\n    \n    const validTimes = cards\n      .map(c => c.average_response_time)\n      .filter(time => time > 0);\n    \n    if (validTimes.length === 0) return 90000;\n    \n    return validTimes.reduce((sum, time) => sum + time, 0) / validTimes.length;\n  }\n  \n  private static getEmptyStatistics() {\n    return {\n      total_cards: 0,\n      by_mastery: {},\n      by_algorithm: {},\n      accuracy_stats: {\n        overall: 0,\n        by_mastery: {},\n      },\n      timing_stats: {\n        average_response_time: 0,\n        fastest_10_percent: 0,\n        slowest_10_percent: 0,\n      },\n      review_distribution: {\n        new: 0,\n        learning: 0,\n        mature: 0,\n      },\n    };\n  }\n}\n\n/**\n * Performance benchmarking utilities\n */\nexport class AlgorithmBenchmark {\n  /**\n   * Benchmark card processing operations\n   */\n  static async benchmarkOperations(cardCounts: number[] = [100, 1000, 5000, 10000]): Promise<{\n    operations: Array<{\n      operation: string;\n      cardCount: number;\n      executionTime: number;\n      operationsPerSecond: number;\n    }>;\n    summary: {\n      fastest_operation: string;\n      slowest_operation: string;\n      scalability_score: number;\n    };\n  }> {\n    const results: Array<{\n      operation: string;\n      cardCount: number;\n      executionTime: number;\n      operationsPerSecond: number;\n    }> = [];\n\n    for (const count of cardCounts) {\n      // Generate test cards\n      const testCards = this.generateTestCards(count);\n      \n      // Benchmark different operations\n      const operations = [\n        { name: 'sort', op: () => AlgorithmOptimizer.sortCardsByPriority(testCards) },\n        { name: 'filter', op: () => AlgorithmOptimizer.filterCards(testCards, { mastery_level: ['learning', 'young'] }) },\n        { name: 'statistics', op: () => AlgorithmOptimizer.calculateBulkStatistics(testCards) },\n        { name: 'index', op: () => AlgorithmOptimizer.createCardIndex(testCards) },\n      ];\n\n      for (const { name, op } of operations) {\n        const { executionTime } = AlgorithmOptimizer.monitorPerformance(op, `${name}-${count}`);\n        \n        results.push({\n          operation: name,\n          cardCount: count,\n          executionTime,\n          operationsPerSecond: Math.round((count / executionTime) * 1000),\n        });\n      }\n    }\n\n    // Calculate summary statistics\n    const avgTimes = new Map<string, number>();\n    results.forEach(r => {\n      const current = avgTimes.get(r.operation) || 0;\n      avgTimes.set(r.operation, current + r.executionTime);\n    });\n\n    let fastestOp = '';\n    let slowestOp = '';\n    let minTime = Infinity;\n    let maxTime = 0;\n\n    avgTimes.forEach((totalTime, operation) => {\n      const avgTime = totalTime / cardCounts.length;\n      if (avgTime < minTime) {\n        minTime = avgTime;\n        fastestOp = operation;\n      }\n      if (avgTime > maxTime) {\n        maxTime = avgTime;\n        slowestOp = operation;\n      }\n    });\n\n    // Scalability score (higher is better)\n    const scalabilityScore = Math.round(100 * (1 - (maxTime / minTime - 1)));\n\n    return {\n      operations: results,\n      summary: {\n        fastest_operation: fastestOp,\n        slowest_operation: slowestOp,\n        scalability_score: Math.max(0, scalabilityScore),\n      },\n    };\n  }\n\n  /**\n   * Generate test cards for benchmarking\n   */\n  private static generateTestCards(count: number): UnifiedCard[] {\n    const cards: UnifiedCard[] = [];\n    const algorithms: Array<'sm2' | 'leitner' | 'adaptive' | 'hybrid'> = ['sm2', 'leitner', 'adaptive', 'hybrid'];\n    const masteryLevels: Array<'new' | 'learning' | 'young' | 'mature' | 'mastered'> = \n      ['new', 'learning', 'young', 'mature', 'mastered'];\n\n    for (let i = 0; i < count; i++) {\n      const algorithm = algorithms[i % algorithms.length];\n      const mastery = masteryLevels[i % masteryLevels.length];\n      const now = new Date();\n      \n      const card: UnifiedCard = {\n        phrase_id: `test-card-${i}`,\n        user_id: 'benchmark-user',\n        algorithm_type: algorithm,\n        created_at: new Date(now.getTime() - Math.random() * 30 * 24 * 60 * 60 * 1000),\n        last_reviewed: Math.random() > 0.3 ? new Date(now.getTime() - Math.random() * 7 * 24 * 60 * 60 * 1000) : null,\n        next_review_date: new Date(now.getTime() + (Math.random() - 0.5) * 7 * 24 * 60 * 60 * 1000),\n        mastery_level: mastery,\n        total_reviews: Math.floor(Math.random() * 20),\n        correct_reviews: 0,\n        streak_correct: Math.floor(Math.random() * 5),\n        streak_incorrect: Math.floor(Math.random() * 3),\n        average_response_time: 2000 + Math.random() * 8000,\n        confidence_score: Math.random(),\n      };\n      \n      card.correct_reviews = Math.floor(card.total_reviews * (0.5 + Math.random() * 0.4));\n      cards.push(card);\n    }\n\n    return cards;\n  }\n\n  /**\n   * Memory usage profiling\n   */\n  static profileMemoryUsage(operations: Array<() => any>): {\n    baseline: number;\n    peak: number;\n    final: number;\n    operations: Array<{ name: string; memory: number }>;\n  } {\n    const getMemoryUsage = () => {\n      if (typeof window !== 'undefined' && 'memory' in performance) {\n        return (performance as any).memory.usedJSHeapSize;\n      }\n      return 0;\n    };\n\n    const baseline = getMemoryUsage();\n    let peak = baseline;\n    const operationMemory: Array<{ name: string; memory: number }> = [];\n\n    operations.forEach((op, index) => {\n      op();\n      const current = getMemoryUsage();\n      peak = Math.max(peak, current);\n      operationMemory.push({\n        name: `operation-${index}`,\n        memory: current,\n      });\n    });\n\n    const final = getMemoryUsage();\n\n    return {\n      baseline,\n      peak,\n      final,\n      operations: operationMemory,\n    };\n  }\n}"