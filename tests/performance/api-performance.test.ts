import { describe, it, expect, vi, beforeEach } from 'vitest'
import { measurePerformance } from '../utils/test-helpers'

// Mock fetch for performance testing
const createMockFetch = (delay: number, payload: any) => 
  vi.fn().mockImplementation(() => 
    new Promise(resolve => 
      setTimeout(() => resolve({
        ok: true,
        status: 200,
        json: () => Promise.resolve(payload),
        headers: new Headers(),
      }), delay)
    )
  )

describe('API Performance Tests', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  describe('/api/descriptions/generate', () => {
    it('should respond within acceptable time limits', async () => {
      const mockPayload = {
        success: true,
        data: {
          style: 'narrativo',
          text: 'Test description generated by API',
          language: 'es',
          wordCount: 6,
          generatedAt: new Date().toISOString(),
        }
      }

      global.fetch = createMockFetch(800, mockPayload) // 800ms response time

      const { duration, result } = await measurePerformance(async () => {
        const response = await fetch('/api/descriptions/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: 'https://example.com/test.jpg',
            style: 'narrativo',
            language: 'es',
            maxLength: 200,
          })
        })
        return response.json()
      })

      expect(duration).toBeLessThan(2000) // Should respond within 2 seconds
      expect(result.success).toBe(true)
      expect(result.data.text).toBeTruthy()
    })

    it('should handle concurrent requests efficiently', async () => {
      const mockPayload = {
        success: true,
        data: {
          style: 'narrativo',
          text: 'Concurrent test description',
          language: 'es',
          wordCount: 4,
          generatedAt: new Date().toISOString(),
        }
      }

      global.fetch = createMockFetch(500, mockPayload)

      const requests = Array(5).fill(null).map(() => 
        measurePerformance(async () => {
          const response = await fetch('/api/descriptions/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              imageUrl: 'https://example.com/test.jpg',
              style: 'narrativo',
              language: 'es',
            })
          })
          return response.json()
        })
      )

      const { duration } = await measurePerformance(async () => {
        const results = await Promise.all(requests)
        return results
      })

      // All 5 concurrent requests should complete within 3 seconds
      expect(duration).toBeLessThan(3000)
    })

    it('should maintain performance with large payloads', async () => {
      const mockPayload = {
        success: true,
        data: {
          style: 'narrativo',
          text: 'Lorem ipsum '.repeat(200), // Large text payload
          language: 'es',
          wordCount: 400,
          generatedAt: new Date().toISOString(),
        }
      }

      global.fetch = createMockFetch(1000, mockPayload)

      const { duration, result } = await measurePerformance(async () => {
        const response = await fetch('/api/descriptions/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: 'https://example.com/large-image.jpg',
            style: 'narrativo',
            language: 'es',
            maxLength: 1000,
          })
        })
        return response.json()
      })

      expect(duration).toBeLessThan(3000) // Should handle large payloads within 3 seconds
      expect(result.data.text.length).toBeGreaterThan(1000)
    })
  })

  describe('/api/qa/generate', () => {
    it('should generate Q&A pairs within performance targets', async () => {
      const mockPayload = {
        questions: Array(5).fill(null).map((_, i) => ({
          id: `q${i + 1}`,
          question: `¿Pregunta de prueba ${i + 1}?`,
          answer: `Respuesta de prueba ${i + 1}`,
          difficulty: 'beginner',
          category: 'description',
          language: 'es',
          generatedAt: new Date().toISOString(),
        })),
        metadata: {
          count: 5,
          language: 'es',
          generatedAt: new Date().toISOString(),
        }
      }

      global.fetch = createMockFetch(1200, mockPayload) // 1.2 seconds response time

      const { duration, result } = await measurePerformance(async () => {
        const response = await fetch('/api/qa/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            description: 'Una casa grande con jardín verde.',
            language: 'es',
            count: 5,
          })
        })
        return response.json()
      })

      expect(duration).toBeLessThan(3000) // Should generate within 3 seconds
      expect(result.questions).toHaveLength(5)
    })

    it('should scale performance with question count', async () => {
      const testCounts = [1, 3, 5, 10]
      const performanceResults: { count: number; duration: number }[] = []

      for (const count of testCounts) {
        const mockPayload = {
          questions: Array(count).fill(null).map((_, i) => ({
            id: `q${i + 1}`,
            question: `¿Pregunta ${i + 1}?`,
            answer: `Respuesta ${i + 1}`,
            difficulty: 'beginner',
            category: 'description',
            language: 'es',
            generatedAt: new Date().toISOString(),
          })),
          metadata: { count, language: 'es', generatedAt: new Date().toISOString() }
        }

        // Simulate longer response time for more questions
        global.fetch = createMockFetch(200 + (count * 100), mockPayload)

        const { duration } = await measurePerformance(async () => {
          const response = await fetch('/api/qa/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              description: 'Test description for performance testing',
              language: 'es',
              count,
            })
          })
          return response.json()
        })

        performanceResults.push({ count, duration })
      }

      // Verify performance scales reasonably
      const maxDuration = Math.max(...performanceResults.map(r => r.duration))
      expect(maxDuration).toBeLessThan(5000) // Even 10 questions should complete within 5 seconds

      // Verify performance roughly scales linearly (not exponentially)
      const minDuration = Math.min(...performanceResults.map(r => r.duration))
      const scaleFactor = maxDuration / minDuration
      expect(scaleFactor).toBeLessThan(10) // Should not scale more than 10x
    })
  })

  describe('/api/vocabulary/save', () => {
    it('should save vocabulary items quickly', async () => {
      const mockPayload = {
        success: true,
        data: {
          id: 'new-vocab-item',
          spanish_text: 'casa',
          english_translation: 'house',
          category: 'home',
          difficulty_level: 1,
          created_at: new Date().toISOString(),
        }
      }

      global.fetch = createMockFetch(300, mockPayload) // 300ms response time

      const { duration, result } = await measurePerformance(async () => {
        const response = await fetch('/api/vocabulary/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            spanish_text: 'casa',
            english_translation: 'house',
            category: 'home',
            difficulty_level: 1,
          })
        })
        return response.json()
      })

      expect(duration).toBeLessThan(1000) // Should save within 1 second
      expect(result.success).toBe(true)
    })

    it('should handle batch operations efficiently', async () => {
      const vocabularyItems = Array(10).fill(null).map((_, i) => ({
        spanish_text: `palabra${i}`,
        english_translation: `word${i}`,
        category: 'test',
        difficulty_level: 1,
      }))

      const mockPayload = {
        success: true,
        data: { saved: vocabularyItems.length }
      }

      global.fetch = createMockFetch(800, mockPayload)

      const { duration } = await measurePerformance(async () => {
        const requests = vocabularyItems.map(item => 
          fetch('/api/vocabulary/save', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(item),
          })
        )
        
        return Promise.all(requests)
      })

      expect(duration).toBeLessThan(5000) // Should handle 10 saves within 5 seconds
    })
  })

  describe('API Response Time Monitoring', () => {
    it('should track response times for all endpoints', async () => {
      const endpoints = [
        { path: '/api/descriptions/generate', expectedMaxTime: 2000 },
        { path: '/api/qa/generate', expectedMaxTime: 3000 },
        { path: '/api/vocabulary/save', expectedMaxTime: 1000 },
        { path: '/api/phrases/extract', expectedMaxTime: 2500 },
        { path: '/api/images/search', expectedMaxTime: 1500 },
      ]

      const results = []

      for (const endpoint of endpoints) {
        const mockPayload = { success: true, data: 'test response' }
        global.fetch = createMockFetch(endpoint.expectedMaxTime * 0.7, mockPayload)

        const { duration } = await measurePerformance(async () => {
          const response = await fetch(endpoint.path, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ test: 'data' }),
          })
          return response.json()
        })

        results.push({
          endpoint: endpoint.path,
          duration,
          expectedMax: endpoint.expectedMaxTime,
          passed: duration < endpoint.expectedMaxTime,
        })
      }

      // All endpoints should meet their performance targets
      results.forEach(result => {
        expect(result.passed).toBe(true)
        console.log(`${result.endpoint}: ${result.duration}ms (target: <${result.expectedMax}ms)`)
      })
    })

    it('should maintain consistent performance under load', async () => {
      const loadTestResults: number[] = []
      const iterations = 20

      for (let i = 0; i < iterations; i++) {
        const mockPayload = { success: true, data: `response ${i}` }
        global.fetch = createMockFetch(500 + Math.random() * 200, mockPayload) // 500-700ms

        const { duration } = await measurePerformance(async () => {
          const response = await fetch('/api/descriptions/generate', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              imageUrl: 'https://example.com/test.jpg',
              style: 'narrativo',
            })
          })
          return response.json()
        })

        loadTestResults.push(duration)
      }

      // Calculate performance statistics
      const avgDuration = loadTestResults.reduce((a, b) => a + b) / loadTestResults.length
      const maxDuration = Math.max(...loadTestResults)
      const minDuration = Math.min(...loadTestResults)

      // Performance should be consistent
      expect(avgDuration).toBeLessThan(1000) // Average response time under 1 second
      expect(maxDuration).toBeLessThan(2000) // No response over 2 seconds
      expect(maxDuration - minDuration).toBeLessThan(1000) // Variation under 1 second

      console.log(`Load test results - Avg: ${avgDuration.toFixed(2)}ms, Min: ${minDuration}ms, Max: ${maxDuration}ms`)
    })
  })

  describe('Memory and Resource Usage', () => {
    it('should not cause memory leaks during repeated operations', async () => {
      const initialMemory = (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0
      
      // Simulate repeated API calls
      for (let i = 0; i < 50; i++) {
        const mockPayload = { success: true, data: `iteration ${i}` }
        global.fetch = createMockFetch(100, mockPayload)

        await fetch('/api/descriptions/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            imageUrl: 'https://example.com/test.jpg',
            style: 'narrativo',
          })
        })

        // Force garbage collection if available
        if (global.gc) {
          global.gc()
        }
      }

      const finalMemory = (performance as any).memory ? (performance as any).memory.usedJSHeapSize : 0
      
      if ((performance as any).memory) {
        const memoryIncrease = finalMemory - initialMemory
        const maxAcceptableIncrease = 10 * 1024 * 1024 // 10MB
        
        expect(memoryIncrease).toBeLessThan(maxAcceptableIncrease)
        console.log(`Memory increase: ${(memoryIncrease / 1024 / 1024).toFixed(2)}MB`)
      }
    })

    it('should handle timeout scenarios gracefully', async () => {
      // Mock a slow response that times out
      global.fetch = vi.fn().mockImplementation(() => 
        new Promise((resolve) => {
          setTimeout(() => resolve({
            ok: false,
            status: 408,
            json: () => Promise.resolve({ error: 'Request timeout' }),
            headers: new Headers(),
          }), 10000) // 10 second delay
        })
      )

      const { duration } = await measurePerformance(async () => {
        try {
          const response = await Promise.race([
            fetch('/api/descriptions/generate', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                imageUrl: 'https://example.com/test.jpg',
                style: 'narrativo',
              })
            }),
            new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Request timeout')), 5000)
            )
          ])
          return response
        } catch (error) {
          return { error: error instanceof Error ? error.message : String(error) }
        }
      })

      // Should timeout within 5 seconds and handle gracefully
      expect(duration).toBeLessThan(6000)
    })
  })
})