/**\n * Test Suite for Leitner System Algorithm\n * Tests the box-based spaced repetition system\n */\n\nimport { describe, test, expect, beforeEach } from 'vitest';\nimport { LeitnerSystemAlgorithm, LeitnerCard, LeitnerUtils } from '../../../src/lib/algorithms/leitner-system';\n\ndescribe('LeitnerSystemAlgorithm', () => {\n  let testCard: LeitnerCard;\n  const userId = 'test-user';\n  const phraseId = 'test-phrase';\n\n  beforeEach(() => {\n    testCard = LeitnerSystemAlgorithm.createCard(phraseId, userId);\n  });\n\n  describe('createCard', () => {\n    test('should create a new card in box 1', () => {\n      expect(testCard.phrase_id).toBe(phraseId);\n      expect(testCard.user_id).toBe(userId);\n      expect(testCard.box_level).toBe(1);\n      expect(testCard.last_reviewed).toBeNull();\n      expect(testCard.correct_count).toBe(0);\n      expect(testCard.incorrect_count).toBe(0);\n      expect(testCard.next_review_date).toBeInstanceOf(Date);\n      expect(testCard.created_at).toBeInstanceOf(Date);\n    });\n\n    test('should set next_review_date to current time for new cards', () => {\n      const now = new Date();\n      const timeDiff = Math.abs(testCard.next_review_date.getTime() - now.getTime());\n      expect(timeDiff).toBeLessThan(1000); // Within 1 second\n    });\n  });\n\n  describe('processReview', () => {\n    test('should advance card to next box on correct response', () => {\n      const processed = LeitnerSystemAlgorithm.processReview(testCard, true);\n      \n      expect(processed.box_level).toBe(2);\n      expect(processed.correct_count).toBe(1);\n      expect(processed.incorrect_count).toBe(0);\n      expect(processed.last_reviewed).toBeInstanceOf(Date);\n      \n      // Next review should be in 2 days (box 2 interval)\n      const expectedDate = new Date();\n      expectedDate.setDate(expectedDate.getDate() + 2);\n      const timeDiff = Math.abs(processed.next_review_date.getTime() - expectedDate.getTime());\n      expect(timeDiff).toBeLessThan(60000); // Within 1 minute\n    });\n\n    test('should move card back to box 1 on incorrect response', () => {\n      // First advance the card to box 3\n      let card = testCard;\n      card = LeitnerSystemAlgorithm.processReview(card, true); // Box 2\n      card = LeitnerSystemAlgorithm.processReview(card, true); // Box 3\n      expect(card.box_level).toBe(3);\n      \n      // Now fail it\n      const failed = LeitnerSystemAlgorithm.processReview(card, false);\n      expect(failed.box_level).toBe(1);\n      expect(failed.incorrect_count).toBe(1);\n      \n      // Should be due tomorrow (box 1 interval)\n      const expectedDate = new Date();\n      expectedDate.setDate(expectedDate.getDate() + 1);\n      const timeDiff = Math.abs(failed.next_review_date.getTime() - expectedDate.getTime());\n      expect(timeDiff).toBeLessThan(60000);\n    });\n\n    test('should not advance beyond maximum box level', () => {\n      let card = testCard;\n      \n      // Advance to maximum box level\n      for (let i = 1; i < 7; i++) {\n        card = LeitnerSystemAlgorithm.processReview(card, true);\n      }\n      expect(card.box_level).toBe(7);\n      \n      // Try to advance further\n      const maxAdvanced = LeitnerSystemAlgorithm.processReview(card, true);\n      expect(maxAdvanced.box_level).toBe(7); // Should stay at max\n    });\n\n    test('should track correct and incorrect counts', () => {\n      let card = testCard;\n      \n      // Do some correct reviews\n      card = LeitnerSystemAlgorithm.processReview(card, true);\n      card = LeitnerSystemAlgorithm.processReview(card, true);\n      expect(card.correct_count).toBe(2);\n      expect(card.incorrect_count).toBe(0);\n      \n      // Do some incorrect reviews\n      card = LeitnerSystemAlgorithm.processReview(card, false);\n      card = LeitnerSystemAlgorithm.processReview(card, false);\n      expect(card.correct_count).toBe(2);\n      expect(card.incorrect_count).toBe(2);\n    });\n\n    test('should calculate correct intervals for each box', () => {\n      const intervals = [1, 2, 4, 8, 16, 32, 64]; // Expected box intervals\n      let card = testCard;\n      \n      for (let i = 0; i < intervals.length; i++) {\n        const processed = LeitnerSystemAlgorithm.processReview(card, true);\n        const expectedDays = intervals[Math.min(i + 1, intervals.length - 1)];\n        \n        const expectedDate = new Date();\n        expectedDate.setDate(expectedDate.getDate() + expectedDays);\n        \n        const timeDiff = Math.abs(processed.next_review_date.getTime() - expectedDate.getTime());\n        expect(timeDiff).toBeLessThan(60000); // Within 1 minute\n        \n        card = processed;\n      }\n    });\n  });\n\n  describe('getCardsDue', () => {\n    test('should return cards due for review', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create overdue card\n      const overdueCard = LeitnerSystemAlgorithm.createCard('overdue', userId);\n      overdueCard.next_review_date = new Date(now.getTime() - 60000); // 1 minute ago\n      cards.push(overdueCard);\n      \n      // Create future card\n      const futureCard = LeitnerSystemAlgorithm.createCard('future', userId);\n      futureCard.next_review_date = new Date(now.getTime() + 60000); // 1 minute from now\n      cards.push(futureCard);\n      \n      // Create card due now\n      const dueCard = LeitnerSystemAlgorithm.createCard('due', userId);\n      dueCard.next_review_date = now;\n      cards.push(dueCard);\n      \n      const dueCards = LeitnerSystemAlgorithm.getCardsDue(cards);\n      expect(dueCards).toHaveLength(2);\n      expect(dueCards.map(c => c.phrase_id)).toContain('overdue');\n      expect(dueCards.map(c => c.phrase_id)).toContain('due');\n      expect(dueCards.map(c => c.phrase_id)).not.toContain('future');\n    });\n\n    test('should prioritize by box level then by overdue time', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create box 3 card (high level, less priority)\n      const box3Card = LeitnerSystemAlgorithm.createCard('box3', userId);\n      box3Card.box_level = 3;\n      box3Card.next_review_date = new Date(now.getTime() - 120000); // 2 minutes ago\n      cards.push(box3Card);\n      \n      // Create box 1 card (low level, high priority)\n      const box1Card = LeitnerSystemAlgorithm.createCard('box1', userId);\n      box1Card.box_level = 1;\n      box1Card.next_review_date = new Date(now.getTime() - 60000); // 1 minute ago\n      cards.push(box1Card);\n      \n      const dueCards = LeitnerSystemAlgorithm.getCardsDue(cards);\n      expect(dueCards[0].phrase_id).toBe('box1'); // Lower box level first\n      expect(dueCards[1].phrase_id).toBe('box3');\n    });\n\n    test('should sort by overdue time within same box level', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create two box 1 cards with different overdue times\n      const lessOverdue = LeitnerSystemAlgorithm.createCard('less', userId);\n      lessOverdue.box_level = 1;\n      lessOverdue.next_review_date = new Date(now.getTime() - 60000); // 1 min ago\n      \n      const moreOverdue = LeitnerSystemAlgorithm.createCard('more', userId);\n      moreOverdue.box_level = 1;\n      moreOverdue.next_review_date = new Date(now.getTime() - 120000); // 2 min ago\n      \n      cards.push(lessOverdue, moreOverdue);\n      \n      const dueCards = LeitnerSystemAlgorithm.getCardsDue(cards);\n      expect(dueCards[0].phrase_id).toBe('more'); // More overdue first\n      expect(dueCards[1].phrase_id).toBe('less');\n    });\n  });\n\n  describe('organizeIntoBoxes', () => {\n    test('should organize cards into correct boxes', () => {\n      const cards: LeitnerCard[] = [];\n      \n      // Create cards in different boxes\n      for (let box = 1; box <= 7; box++) {\n        for (let i = 0; i < 3; i++) {\n          const card = LeitnerSystemAlgorithm.createCard(`box${box}-card${i}`, userId);\n          card.box_level = box;\n          cards.push(card);\n        }\n      }\n      \n      const boxes = LeitnerSystemAlgorithm.organizeIntoBoxes(cards);\n      \n      expect(boxes).toHaveLength(7);\n      boxes.forEach((box, index) => {\n        expect(box.level).toBe(index + 1);\n        expect(box.cards).toHaveLength(3);\n        expect(box.interval_days).toBe([1, 2, 4, 8, 16, 32, 64][index]);\n      });\n    });\n\n    test('should calculate next review date for each box', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create cards with different review dates\n      const card1 = LeitnerSystemAlgorithm.createCard('card1', userId);\n      card1.box_level = 2;\n      card1.next_review_date = new Date(now.getTime() + 86400000); // Tomorrow\n      \n      const card2 = LeitnerSystemAlgorithm.createCard('card2', userId);\n      card2.box_level = 2;\n      card2.next_review_date = new Date(now.getTime() + 2 * 86400000); // Day after tomorrow\n      \n      cards.push(card1, card2);\n      \n      const boxes = LeitnerSystemAlgorithm.organizeIntoBoxes(cards);\n      const box2 = boxes.find(b => b.level === 2)!;\n      \n      // Next review for the box should be the earliest card's review date\n      expect(box2.next_review_date.getTime()).toBe(card1.next_review_date.getTime());\n    });\n  });\n\n  describe('calculateRetentionStats', () => {\n    test('should return empty stats for no cards', () => {\n      const stats = LeitnerSystemAlgorithm.calculateRetentionStats([]);\n      expect(stats.total_cards).toBe(0);\n      expect(stats.average_box_level).toBe(0);\n      expect(stats.success_rate).toBe(0);\n    });\n\n    test('should calculate correct statistics', () => {\n      const cards: LeitnerCard[] = [];\n      \n      // Create cards with different characteristics\n      for (let i = 1; i <= 7; i++) {\n        const card = LeitnerSystemAlgorithm.createCard(`card-${i}`, userId);\n        card.box_level = i;\n        card.correct_count = i * 2;\n        card.incorrect_count = i;\n        cards.push(card);\n      }\n      \n      const stats = LeitnerSystemAlgorithm.calculateRetentionStats(cards);\n      \n      expect(stats.total_cards).toBe(7);\n      expect(stats.average_box_level).toBe(4); // (1+2+3+4+5+6+7)/7\n      expect(stats.cards_new).toBe(1); // Box 1\n      expect(stats.cards_learning).toBe(4); // Boxes 2-5\n      expect(stats.cards_mastered).toBe(2); // Boxes 6-7\n      \n      // Success rate = total_correct / total_attempts\n      const totalCorrect = cards.reduce((sum, c) => sum + c.correct_count, 0);\n      const totalAttempts = cards.reduce((sum, c) => sum + c.correct_count + c.incorrect_count, 0);\n      expect(stats.success_rate).toBeCloseTo(totalCorrect / totalAttempts, 2);\n    });\n\n    test('should track cards by box distribution', () => {\n      const cards: LeitnerCard[] = [];\n      \n      // Create specific distribution: 3 in box 1, 2 in box 2, 1 in box 3, etc.\n      for (let box = 1; box <= 7; box++) {\n        const count = Math.max(1, 8 - box);\n        for (let i = 0; i < count; i++) {\n          const card = LeitnerSystemAlgorithm.createCard(`box${box}-${i}`, userId);\n          card.box_level = box;\n          cards.push(card);\n        }\n      }\n      \n      const stats = LeitnerSystemAlgorithm.calculateRetentionStats(cards);\n      expect(stats.cards_by_box[0]).toBe(7); // Box 1\n      expect(stats.cards_by_box[1]).toBe(6); // Box 2\n      expect(stats.cards_by_box[6]).toBe(1); // Box 7\n    });\n  });\n\n  describe('getStudyRecommendations', () => {\n    test('should identify priority boxes with overdue cards', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create overdue cards in boxes 1 and 3\n      const overdueBox1 = LeitnerSystemAlgorithm.createCard('overdue1', userId);\n      overdueBox1.box_level = 1;\n      overdueBox1.next_review_date = new Date(now.getTime() - 86400000);\n      \n      const overdueBox3 = LeitnerSystemAlgorithm.createCard('overdue3', userId);\n      overdueBox3.box_level = 3;\n      overdueBox3.next_review_date = new Date(now.getTime() - 86400000);\n      \n      // Create future card in box 2\n      const futureBox2 = LeitnerSystemAlgorithm.createCard('future2', userId);\n      futureBox2.box_level = 2;\n      futureBox2.next_review_date = new Date(now.getTime() + 86400000);\n      \n      cards.push(overdueBox1, overdueBox3, futureBox2);\n      \n      const recommendations = LeitnerSystemAlgorithm.getStudyRecommendations(cards);\n      expect(recommendations.priority_boxes).toContain(1);\n      expect(recommendations.priority_boxes).toContain(3);\n      expect(recommendations.priority_boxes).not.toContain(2);\n    });\n\n    test('should adjust daily target based on overdue cards', () => {\n      const cards: LeitnerCard[] = [];\n      const now = new Date();\n      \n      // Create many overdue cards\n      for (let i = 0; i < 20; i++) {\n        const card = LeitnerSystemAlgorithm.createCard(`overdue-${i}`, userId);\n        card.box_level = Math.floor(i / 5) + 1; // Distribute across different boxes\n        card.next_review_date = new Date(now.getTime() - 86400000);\n        cards.push(card);\n      }\n      \n      const recommendations = LeitnerSystemAlgorithm.getStudyRecommendations(cards);\n      expect(recommendations.daily_review_target).toBeGreaterThan(20); // Should increase due to backlog\n      expect(recommendations.focus_areas).toContain('struggling_cards');\n    });\n\n    test('should provide focus area recommendations', () => {\n      const cards: LeitnerCard[] = [];\n      \n      // Create many new cards (box 1)\n      for (let i = 0; i < 10; i++) {\n        const card = LeitnerSystemAlgorithm.createCard(`new-${i}`, userId);\n        card.box_level = 1;\n        cards.push(card);\n      }\n      \n      // Create some cards with poor success rate\n      for (let i = 0; i < 5; i++) {\n        const card = LeitnerSystemAlgorithm.createCard(`poor-${i}`, userId);\n        card.box_level = 2;\n        card.correct_count = 1;\n        card.incorrect_count = 4; // Poor success rate\n        cards.push(card);\n      }\n      \n      const recommendations = LeitnerSystemAlgorithm.getStudyRecommendations(cards);\n      expect(recommendations.focus_areas).toContain('new_cards');\n      expect(recommendations.focus_areas).toContain('retention');\n    });\n  });\n});\n\ndescribe('LeitnerUtils', () => {\n  describe('getBoxDescription', () => {\n    test('should return appropriate descriptions for each box', () => {\n      expect(LeitnerUtils.getBoxDescription(1)).toBe('New & Struggling');\n      expect(LeitnerUtils.getBoxDescription(2)).toBe('Learning');\n      expect(LeitnerUtils.getBoxDescription(3)).toBe('Developing');\n      expect(LeitnerUtils.getBoxDescription(4)).toBe('Familiar');\n      expect(LeitnerUtils.getBoxDescription(5)).toBe('Confident');\n      expect(LeitnerUtils.getBoxDescription(6)).toBe('Mastered');\n      expect(LeitnerUtils.getBoxDescription(7)).toBe('Fully Learned');\n      expect(LeitnerUtils.getBoxDescription(8)).toBe('Unknown');\n    });\n  });\n\n  describe('getIntervalDescription', () => {\n    test('should return human-readable interval descriptions', () => {\n      expect(LeitnerUtils.getIntervalDescription(1)).toBe('Daily');\n      expect(LeitnerUtils.getIntervalDescription(2)).toBe('Every 2 days');\n      expect(LeitnerUtils.getIntervalDescription(3)).toBe('Every 1 weeks');\n      expect(LeitnerUtils.getIntervalDescription(4)).toBe('Every 1 weeks');\n      expect(LeitnerUtils.getIntervalDescription(6)).toBe('Every 1 months');\n      expect(LeitnerUtils.getIntervalDescription(7)).toBe('Every 2 months');\n    });\n  });\n\n  describe('getMasteryPercentage', () => {\n    test('should calculate mastery percentage based on box level', () => {\n      expect(LeitnerUtils.getMasteryPercentage(1)).toBe(14); // 1/7 * 100\n      expect(LeitnerUtils.getMasteryPercentage(4)).toBe(57); // 4/7 * 100\n      expect(LeitnerUtils.getMasteryPercentage(7)).toBe(100);\n      expect(LeitnerUtils.getMasteryPercentage(8)).toBe(100); // Capped at 100\n    });\n  });\n\n  describe('qualityToCorrect', () => {\n    test('should convert quality scores to correct/incorrect', () => {\n      expect(LeitnerUtils.qualityToCorrect(0)).toBe(false);\n      expect(LeitnerUtils.qualityToCorrect(1)).toBe(false);\n      expect(LeitnerUtils.qualityToCorrect(2)).toBe(false);\n      expect(LeitnerUtils.qualityToCorrect(3)).toBe(true);\n      expect(LeitnerUtils.qualityToCorrect(4)).toBe(true);\n      expect(LeitnerUtils.qualityToCorrect(5)).toBe(true);\n    });\n  });\n});"