/**\n * Test Suite for Spaced Repetition Algorithm\n * Tests the SM-2 algorithm implementation\n */\n\nimport { describe, test, expect, beforeEach } from 'vitest';\nimport { SpacedRepetitionAlgorithm, SpacedRepetitionCard, SpacedRepetitionUtils } from '../../../src/lib/algorithms/spaced-repetition';\n\ndescribe('SpacedRepetitionAlgorithm', () => {\n  let testCard: SpacedRepetitionCard;\n  const userId = 'test-user';\n  const phraseId = 'test-phrase';\n\n  beforeEach(() => {\n    testCard = SpacedRepetitionAlgorithm.createCard(phraseId, userId);\n  });\n\n  describe('createCard', () => {\n    test('should create a new card with default values', () => {\n      expect(testCard.phrase_id).toBe(phraseId);\n      expect(testCard.user_id).toBe(userId);\n      expect(testCard.interval).toBe(1);\n      expect(testCard.repetition).toBe(0);\n      expect(testCard.easiness_factor).toBe(2.5);\n      expect(testCard.last_reviewed).toBeNull();\n      expect(testCard.next_review_date).toBeInstanceOf(Date);\n      expect(testCard.streak_correct).toBe(0);\n      expect(testCard.streak_incorrect).toBe(0);\n    });\n\n    test('should set next_review_date to current time for new cards', () => {\n      const now = new Date();\n      const timeDiff = Math.abs(testCard.next_review_date.getTime() - now.getTime());\n      expect(timeDiff).toBeLessThan(1000); // Within 1 second\n    });\n  });\n\n  describe('processReview', () => {\n    test('should handle quality scores correctly', () => {\n      // Test perfect response (quality 5)\n      const perfectResponse = SpacedRepetitionAlgorithm.processReview(testCard, 5);\n      expect(perfectResponse.quality).toBe(5);\n      expect(perfectResponse.repetition).toBe(1);\n      expect(perfectResponse.interval).toBe(1);\n      expect(perfectResponse.easiness_factor).toBeGreaterThan(2.5);\n      expect(perfectResponse.last_reviewed).toBeInstanceOf(Date);\n    });\n\n    test('should reset repetition on incorrect response', () => {\n      // First, advance the card\n      const advanced = SpacedRepetitionAlgorithm.processReview(testCard, 4);\n      const advanced2 = SpacedRepetitionAlgorithm.processReview(advanced, 4);\n      expect(advanced2.repetition).toBe(2);\n      expect(advanced2.interval).toBe(6);\n\n      // Now fail it\n      const failed = SpacedRepetitionAlgorithm.processReview(advanced2, 2);\n      expect(failed.repetition).toBe(0);\n      expect(failed.interval).toBe(1);\n    });\n\n    test('should follow SM-2 interval progression', () => {\n      // First repetition\n      const rep1 = SpacedRepetitionAlgorithm.processReview(testCard, 4);\n      expect(rep1.repetition).toBe(1);\n      expect(rep1.interval).toBe(1);\n\n      // Second repetition\n      const rep2 = SpacedRepetitionAlgorithm.processReview(rep1, 4);\n      expect(rep2.repetition).toBe(2);\n      expect(rep2.interval).toBe(6);\n\n      // Third repetition (uses easiness factor)\n      const rep3 = SpacedRepetitionAlgorithm.processReview(rep2, 4);\n      expect(rep3.repetition).toBe(3);\n      expect(rep3.interval).toBeGreaterThan(6);\n    });\n\n    test('should clamp quality values to 0-5 range', () => {\n      const highQuality = SpacedRepetitionAlgorithm.processReview(testCard, 10);\n      expect(highQuality.quality).toBe(5);\n\n      const lowQuality = SpacedRepetitionAlgorithm.processReview(testCard, -5);\n      expect(lowQuality.quality).toBe(0);\n    });\n\n    test('should update easiness factor correctly', () => {\n      const originalEF = testCard.easiness_factor;\n      \n      // Good response should increase EF\n      const goodResponse = SpacedRepetitionAlgorithm.processReview(testCard, 5);\n      expect(goodResponse.easiness_factor).toBeGreaterThan(originalEF);\n      \n      // Poor response should decrease EF\n      const poorResponse = SpacedRepetitionAlgorithm.processReview(testCard, 1);\n      expect(poorResponse.easiness_factor).toBeLessThan(originalEF);\n    });\n\n    test('should respect easiness factor bounds', () => {\n      let card = testCard;\n      \n      // Try to push EF below minimum with many poor responses\n      for (let i = 0; i < 10; i++) {\n        card = SpacedRepetitionAlgorithm.processReview(card, 0);\n      }\n      expect(card.easiness_factor).toBeGreaterThanOrEqual(1.3);\n      \n      // Try to push EF above maximum with many perfect responses\n      card = testCard;\n      for (let i = 0; i < 10; i++) {\n        card = SpacedRepetitionAlgorithm.processReview(card, 5);\n      }\n      expect(card.easiness_factor).toBeLessThanOrEqual(2.5);\n    });\n\n    test('should calculate next review date correctly', () => {\n      const processed = SpacedRepetitionAlgorithm.processReview(testCard, 4);\n      const now = new Date();\n      const expectedDate = new Date(now);\n      expectedDate.setDate(now.getDate() + processed.interval);\n      \n      const timeDiff = Math.abs(processed.next_review_date.getTime() - expectedDate.getTime());\n      expect(timeDiff).toBeLessThan(60000); // Within 1 minute\n    });\n  });\n\n  describe('getCardsDue', () => {\n    test('should return cards due for review', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create overdue card\n      const overdueCard = SpacedRepetitionAlgorithm.createCard('overdue', userId);\n      overdueCard.next_review_date = new Date(now.getTime() - 60000); // 1 minute ago\n      cards.push(overdueCard);\n      \n      // Create future card\n      const futureCard = SpacedRepetitionAlgorithm.createCard('future', userId);\n      futureCard.next_review_date = new Date(now.getTime() + 60000); // 1 minute from now\n      cards.push(futureCard);\n      \n      // Create card due now\n      const dueCard = SpacedRepetitionAlgorithm.createCard('due', userId);\n      dueCard.next_review_date = now;\n      cards.push(dueCard);\n      \n      const dueCards = SpacedRepetitionAlgorithm.getCardsDue(cards);\n      expect(dueCards).toHaveLength(2);\n      expect(dueCards.map(c => c.phrase_id)).toContain('overdue');\n      expect(dueCards.map(c => c.phrase_id)).toContain('due');\n      expect(dueCards.map(c => c.phrase_id)).not.toContain('future');\n    });\n\n    test('should sort due cards by overdue time', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create cards with different overdue times\n      const slightlyOverdue = SpacedRepetitionAlgorithm.createCard('slight', userId);\n      slightlyOverdue.next_review_date = new Date(now.getTime() - 60000); // 1 min ago\n      \n      const veryOverdue = SpacedRepetitionAlgorithm.createCard('very', userId);\n      veryOverdue.next_review_date = new Date(now.getTime() - 86400000); // 1 day ago\n      \n      cards.push(slightlyOverdue, veryOverdue);\n      \n      const dueCards = SpacedRepetitionAlgorithm.getCardsDue(cards);\n      expect(dueCards[0].phrase_id).toBe('very'); // Most overdue first\n      expect(dueCards[1].phrase_id).toBe('slight');\n    });\n  });\n\n  describe('getNewCards', () => {\n    test('should return new cards with repetition 0', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      \n      // Create new cards\n      for (let i = 0; i < 5; i++) {\n        cards.push(SpacedRepetitionAlgorithm.createCard(`new-${i}`, userId));\n      }\n      \n      // Create reviewed cards\n      for (let i = 0; i < 3; i++) {\n        const reviewedCard = SpacedRepetitionAlgorithm.createCard(`reviewed-${i}`, userId);\n        reviewedCard.repetition = 1;\n        cards.push(reviewedCard);\n      }\n      \n      const newCards = SpacedRepetitionAlgorithm.getNewCards(cards, 3);\n      expect(newCards).toHaveLength(3);\n      newCards.forEach(card => {\n        expect(card.repetition).toBe(0);\n        expect(card.phrase_id).toMatch(/^new-/);\n      });\n    });\n\n    test('should respect the limit parameter', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      \n      for (let i = 0; i < 10; i++) {\n        cards.push(SpacedRepetitionAlgorithm.createCard(`new-${i}`, userId));\n      }\n      \n      const limitedCards = SpacedRepetitionAlgorithm.getNewCards(cards, 5);\n      expect(limitedCards).toHaveLength(5);\n    });\n  });\n\n  describe('getReviewSession', () => {\n    test('should create a balanced review session', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create mix of new and due cards\n      for (let i = 0; i < 15; i++) {\n        cards.push(SpacedRepetitionAlgorithm.createCard(`new-${i}`, userId));\n      }\n      \n      for (let i = 0; i < 25; i++) {\n        const dueCard = SpacedRepetitionAlgorithm.createCard(`due-${i}`, userId);\n        dueCard.next_review_date = new Date(now.getTime() - i * 60000);\n        dueCard.repetition = 1;\n        cards.push(dueCard);\n      }\n      \n      const session = SpacedRepetitionAlgorithm.getReviewSession(cards, 10, 20);\n      \n      expect(session.cards_new).toHaveLength(10);\n      expect(session.cards_due).toHaveLength(20);\n      expect(session.session_stats.total_cards).toBe(30);\n      expect(session.session_stats.cards_reviewed).toBe(0);\n      expect(session.session_stats.average_quality).toBe(0);\n    });\n\n    test('should prioritize overdue cards', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create cards with different overdue times\n      for (let i = 0; i < 10; i++) {\n        const card = SpacedRepetitionAlgorithm.createCard(`card-${i}`, userId);\n        card.next_review_date = new Date(now.getTime() - i * 86400000); // i days ago\n        card.repetition = 1;\n        cards.push(card);\n      }\n      \n      const session = SpacedRepetitionAlgorithm.getReviewSession(cards, 0, 5);\n      \n      // Should get the 5 most overdue cards\n      expect(session.cards_due).toHaveLength(5);\n      expect(session.cards_due[0].phrase_id).toBe('card-9'); // Most overdue\n      expect(session.cards_due[4].phrase_id).toBe('card-5'); // 5th most overdue\n    });\n  });\n\n  describe('calculateRetentionStats', () => {\n    test('should return empty stats for no cards', () => {\n      const stats = SpacedRepetitionAlgorithm.calculateRetentionStats([]);\n      expect(stats.total_cards).toBe(0);\n      expect(stats.average_easiness).toBe(0);\n      expect(stats.retention_rate).toBe(0);\n    });\n\n    test('should calculate correct statistics', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      \n      // Create cards with different characteristics\n      for (let i = 0; i < 10; i++) {\n        const card = SpacedRepetitionAlgorithm.createCard(`card-${i}`, userId);\n        card.repetition = i < 5 ? 0 : i < 8 ? 2 : 5; // 5 new, 3 young, 2 mature\n        card.interval = i < 5 ? 1 : i < 8 ? 10 : 30;\n        card.quality = i < 7 ? 4 : 2; // 7 good, 3 poor (for retention rate)\n        cards.push(card);\n      }\n      \n      const stats = SpacedRepetitionAlgorithm.calculateRetentionStats(cards);\n      \n      expect(stats.total_cards).toBe(10);\n      expect(stats.new_cards).toBe(5);\n      expect(stats.young_cards).toBe(3);\n      expect(stats.mature_cards).toBe(2);\n      expect(stats.retention_rate).toBe(0.7); // 7 out of 10 above quality threshold\n      expect(stats.average_easiness).toBe(2.5); // Default easiness factor\n    });\n  });\n\n  describe('predictForgettingCurve', () => {\n    test('should predict forgetting curve for different card states', () => {\n      // New card with low repetitions\n      const newCard = SpacedRepetitionAlgorithm.createCard('new', userId);\n      newCard.repetition = 1;\n      newCard.easiness_factor = 2.0;\n      newCard.interval = 2;\n      \n      const newPrediction = SpacedRepetitionAlgorithm.predictForgettingCurve(newCard);\n      expect(newPrediction.confidence_level).toBe('low');\n      expect(newPrediction.days_until_50_percent).toBeLessThan(newPrediction.days_until_25_percent);\n      \n      // Mature card with high repetitions\n      const matureCard = SpacedRepetitionAlgorithm.createCard('mature', userId);\n      matureCard.repetition = 6;\n      matureCard.easiness_factor = 2.3;\n      matureCard.interval = 45;\n      \n      const maturePrediction = SpacedRepetitionAlgorithm.predictForgettingCurve(matureCard);\n      expect(maturePrediction.confidence_level).toBe('high');\n      expect(maturePrediction.days_until_50_percent).toBeGreaterThan(newPrediction.days_until_50_percent);\n    });\n  });\n\n  describe('generateStudyRecommendations', () => {\n    test('should provide appropriate recommendations', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create overdue cards\n      for (let i = 0; i < 15; i++) {\n        const card = SpacedRepetitionAlgorithm.createCard(`overdue-${i}`, userId);\n        card.next_review_date = new Date(now.getTime() - 86400000); // 1 day ago\n        card.repetition = 1;\n        cards.push(card);\n      }\n      \n      // Create struggling cards\n      for (let i = 0; i < 5; i++) {\n        const card = SpacedRepetitionAlgorithm.createCard(`struggling-${i}`, userId);\n        card.easiness_factor = 1.5; // Below normal\n        card.quality = 2; // Poor quality\n        cards.push(card);\n      }\n      \n      const recommendations = SpacedRepetitionAlgorithm.generateStudyRecommendations(cards);\n      \n      expect(recommendations.priority_cards).toHaveLength(15); // 10 overdue + 5 struggling\n      expect(recommendations.suggested_daily_new).toBeGreaterThanOrEqual(5);\n      expect(recommendations.suggested_daily_review).toBeGreaterThanOrEqual(20);\n      expect(recommendations.focus_areas).toContain('review_backlog');\n    });\n\n    test('should adjust recommendations based on performance', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      \n      // Create cards with high retention rate\n      for (let i = 0; i < 10; i++) {\n        const card = SpacedRepetitionAlgorithm.createCard(`good-${i}`, userId);\n        card.quality = 5; // Perfect quality\n        cards.push(card);\n      }\n      \n      const goodRecommendations = SpacedRepetitionAlgorithm.generateStudyRecommendations(cards);\n      \n      // Should recommend more new cards for good performance\n      expect(goodRecommendations.suggested_daily_new).toBeGreaterThan(10);\n    });\n  });\n\n  describe('calculateOptimalSchedule', () => {\n    test('should generate realistic daily schedule', () => {\n      const cards: SpacedRepetitionCard[] = [];\n      const now = new Date();\n      \n      // Create cards due on different days\n      for (let day = 0; day < 7; day++) {\n        for (let i = 0; i < 5; i++) {\n          const card = SpacedRepetitionAlgorithm.createCard(`day-${day}-card-${i}`, userId);\n          const dueDate = new Date(now);\n          dueDate.setDate(now.getDate() + day);\n          card.next_review_date = dueDate;\n          card.repetition = 1;\n          cards.push(card);\n        }\n      }\n      \n      const schedule = SpacedRepetitionAlgorithm.calculateOptimalSchedule(cards, 30);\n      \n      expect(schedule.daily_schedule).toHaveLength(7);\n      expect(schedule.weekly_summary.total_new_cards).toBeGreaterThan(0);\n      expect(schedule.weekly_summary.total_reviews).toBeGreaterThan(0);\n      expect(schedule.weekly_summary.estimated_hours).toBeGreaterThan(0);\n      \n      // Check that estimated time is reasonable\n      schedule.daily_schedule.forEach(day => {\n        expect(day.estimated_minutes).toBeLessThanOrEqual(60); // Max 1 hour per day\n      });\n    });\n  });\n});\n\ndescribe('SpacedRepetitionUtils', () => {\n  describe('normalizeQuality', () => {\n    test('should convert different scales to 0-5 scale', () => {\n      expect(SpacedRepetitionUtils.normalizeQuality(50, 100)).toBe(3); // 50/100 = 0.5 * 5 = 2.5 -> 3\n      expect(SpacedRepetitionUtils.normalizeQuality(3, 4)).toBe(4); // 3/4 = 0.75 * 5 = 3.75 -> 4\n      expect(SpacedRepetitionUtils.normalizeQuality(10, 10)).toBe(5); // Perfect score\n    });\n  });\n\n  describe('getDifficultyDescription', () => {\n    test('should return appropriate difficulty descriptions', () => {\n      expect(SpacedRepetitionUtils.getDifficultyDescription(2.4)).toBe('Easy');\n      expect(SpacedRepetitionUtils.getDifficultyDescription(2.1)).toBe('Normal');\n      expect(SpacedRepetitionUtils.getDifficultyDescription(1.8)).toBe('Hard');\n      expect(SpacedRepetitionUtils.getDifficultyDescription(1.5)).toBe('Very Hard');\n    });\n  });\n\n  describe('getNextReviewDescription', () => {\n    test('should return human-readable review descriptions', () => {\n      const now = new Date();\n      \n      const overdue = new Date(now.getTime() - 86400000); // 1 day ago\n      expect(SpacedRepetitionUtils.getNextReviewDescription(overdue)).toBe('1 days overdue');\n      \n      const today = new Date(now);\n      expect(SpacedRepetitionUtils.getNextReviewDescription(today)).toBe('Due today');\n      \n      const tomorrow = new Date(now.getTime() + 86400000); // 1 day from now\n      expect(SpacedRepetitionUtils.getNextReviewDescription(tomorrow)).toBe('Due tomorrow');\n      \n      const nextWeek = new Date(now.getTime() + 7 * 86400000); // 1 week from now\n      expect(SpacedRepetitionUtils.getNextReviewDescription(nextWeek)).toBe('Due in 1 weeks');\n    });\n  });\n\n  describe('getMasteryLevel', () => {\n    test('should classify cards by mastery level', () => {\n      const newCard = SpacedRepetitionAlgorithm.createCard('new', 'user');\n      expect(SpacedRepetitionUtils.getMasteryLevel(newCard)).toBe('new');\n      \n      const learningCard = { ...newCard, repetition: 2, interval: 5 };\n      expect(SpacedRepetitionUtils.getMasteryLevel(learningCard)).toBe('learning');\n      \n      const youngCard = { ...newCard, repetition: 3, interval: 15 };\n      expect(SpacedRepetitionUtils.getMasteryLevel(youngCard)).toBe('young');\n      \n      const matureCard = { ...newCard, repetition: 5, interval: 50 };\n      expect(SpacedRepetitionUtils.getMasteryLevel(matureCard)).toBe('mature');\n      \n      const masteredCard = { ...newCard, repetition: 10, interval: 120 };\n      expect(SpacedRepetitionUtils.getMasteryLevel(masteredCard)).toBe('mastered');\n    });\n  });\n});"