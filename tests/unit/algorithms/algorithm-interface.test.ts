/**\n * Test Suite for Algorithm Interface\n * Tests the unified interface for all learning algorithms\n */\n\nimport { describe, test, expect, beforeEach, vi } from 'vitest';\nimport { LearningAlgorithmInterface, UnifiedCard, UnifiedReviewResponse, StudySessionConfig } from '../../../src/lib/algorithms/algorithm-interface';\n\ndescribe('LearningAlgorithmInterface', () => {\n  let algorithmInterface: LearningAlgorithmInterface;\n  const userId = 'test-user';\n  const phraseId = 'test-phrase';\n\n  beforeEach(() => {\n    algorithmInterface = LearningAlgorithmInterface.getInstance();\n  });\n\n  describe('getInstance', () => {\n    test('should return singleton instance', () => {\n      const instance1 = LearningAlgorithmInterface.getInstance();\n      const instance2 = LearningAlgorithmInterface.getInstance();\n      expect(instance1).toBe(instance2);\n    });\n  });\n\n  describe('createCard', () => {\n    test('should create SM-2 card with correct data structure', () => {\n      const card = algorithmInterface.createCard(phraseId, userId, 'sm2');\n      \n      expect(card.phrase_id).toBe(phraseId);\n      expect(card.user_id).toBe(userId);\n      expect(card.algorithm_type).toBe('sm2');\n      expect(card.mastery_level).toBe('new');\n      expect(card.total_reviews).toBe(0);\n      expect(card.sm2_data).toBeDefined();\n      expect(card.sm2_data?.interval).toBe(1);\n      expect(card.sm2_data?.repetition).toBe(0);\n      expect(card.sm2_data?.easiness_factor).toBe(2.5);\n    });\n\n    test('should create Leitner card with correct data structure', () => {\n      const card = algorithmInterface.createCard(phraseId, userId, 'leitner');\n      \n      expect(card.algorithm_type).toBe('leitner');\n      expect(card.leitner_data).toBeDefined();\n      expect(card.leitner_data?.box_level).toBe(1);\n      expect(card.leitner_data?.correct_count).toBe(0);\n      expect(card.leitner_data?.incorrect_count).toBe(0);\n    });\n\n    test('should create adaptive card with correct data structure', () => {\n      const card = algorithmInterface.createCard(phraseId, userId, 'adaptive', 3);\n      \n      expect(card.algorithm_type).toBe('adaptive');\n      expect(card.adaptive_data).toBeDefined();\n      expect(card.adaptive_data?.base_difficulty).toBe(3);\n      expect(card.adaptive_data?.user_difficulty).toBe(3);\n      expect(card.adaptive_data?.adaptation_factor).toBe(1.0);\n    });\n\n    test('should create hybrid card with both SM-2 and adaptive data', () => {\n      const card = algorithmInterface.createCard(phraseId, userId, 'hybrid', 4);\n      \n      expect(card.algorithm_type).toBe('hybrid');\n      expect(card.sm2_data).toBeDefined();\n      expect(card.adaptive_data).toBeDefined();\n      expect(card.adaptive_data?.base_difficulty).toBe(4);\n    });\n\n    test('should initialize common fields correctly', () => {\n      const card = algorithmInterface.createCard(phraseId, userId, 'sm2');\n      \n      expect(card.created_at).toBeInstanceOf(Date);\n      expect(card.last_reviewed).toBeNull();\n      expect(card.next_review_date).toBeInstanceOf(Date);\n      expect(card.streak_correct).toBe(0);\n      expect(card.streak_incorrect).toBe(0);\n      expect(card.average_response_time).toBe(0);\n      expect(card.confidence_score).toBe(0);\n    });\n  });\n\n  describe('processReview', () => {\n    let testCard: UnifiedCard;\n    let reviewResponse: UnifiedReviewResponse;\n\n    beforeEach(() => {\n      testCard = algorithmInterface.createCard(phraseId, userId, 'sm2');\n      reviewResponse = {\n        phrase_id: phraseId,\n        quality: 4,\n        response_time_ms: 3000,\n        confidence_level: 4,\n        difficulty_rating: 3,\n        hint_used: false,\n        attempt_count: 1,\n        context: {\n          session_id: 'test-session',\n          timestamp: new Date(),\n          time_of_day: 'afternoon',\n          session_progress: 0.5,\n        },\n      };\n    });\n\n    test('should update common metrics correctly', () => {\n      const processed = algorithmInterface.processReview(testCard, reviewResponse);\n      \n      expect(processed.total_reviews).toBe(1);\n      expect(processed.correct_reviews).toBe(1);\n      expect(processed.streak_correct).toBe(1);\n      expect(processed.streak_incorrect).toBe(0);\n      expect(processed.last_reviewed).toEqual(reviewResponse.context.timestamp);\n      expect(processed.average_response_time).toBe(3000);\n      expect(processed.confidence_score).toBe(0.75); // (4-1)/4\n    });\n\n    test('should handle incorrect responses', () => {\n      reviewResponse.quality = 2; // Below threshold\n      const processed = algorithmInterface.processReview(testCard, reviewResponse);\n      \n      expect(processed.correct_reviews).toBe(0);\n      expect(processed.streak_correct).toBe(0);\n      expect(processed.streak_incorrect).toBe(1);\n    });\n\n    test('should update average response time with exponential moving average', () => {\n      // First review\n      const first = algorithmInterface.processReview(testCard, { ...reviewResponse, response_time_ms: 5000 });\n      expect(first.average_response_time).toBe(5000);\n      \n      // Second review\n      const second = algorithmInterface.processReview(first, { ...reviewResponse, response_time_ms: 1000 });\n      const expectedAvg = 0.3 * 1000 + 0.7 * 5000; // Alpha = 0.3\n      expect(second.average_response_time).toBeCloseTo(expectedAvg, 0);\n    });\n\n    test('should process SM-2 algorithm correctly', () => {\n      const processed = algorithmInterface.processReview(testCard, reviewResponse);\n      \n      expect(processed.sm2_data?.repetition).toBe(1);\n      expect(processed.sm2_data?.quality).toBe(4);\n      expect(processed.sm2_data?.last_reviewed).toBeInstanceOf(Date);\n      expect(processed.next_review_date).toEqual(processed.sm2_data?.next_review_date);\n    });\n\n    test('should process Leitner system correctly', () => {\n      const leitnerCard = algorithmInterface.createCard(phraseId, userId, 'leitner');\n      const processed = algorithmInterface.processReview(leitnerCard, reviewResponse);\n      \n      expect(processed.leitner_data?.box_level).toBe(2); // Should advance on correct\n      expect(processed.leitner_data?.correct_count).toBe(1);\n      expect(processed.next_review_date).toEqual(processed.leitner_data?.next_review_date);\n    });\n\n    test('should process adaptive algorithm correctly', () => {\n      const adaptiveCard = algorithmInterface.createCard(phraseId, userId, 'adaptive');\n      const processed = algorithmInterface.processReview(adaptiveCard, reviewResponse);\n      \n      expect(processed.adaptive_data?.performance_history).toHaveLength(1);\n      expect(processed.adaptive_data?.last_adaptation).toBeInstanceOf(Date);\n      expect(processed.next_review_date).toBeInstanceOf(Date);\n    });\n\n    test('should process hybrid algorithm correctly', () => {\n      const hybridCard = algorithmInterface.createCard(phraseId, userId, 'hybrid');\n      const processed = algorithmInterface.processReview(hybridCard, reviewResponse);\n      \n      expect(processed.sm2_data?.repetition).toBe(1);\n      expect(processed.adaptive_data?.performance_history).toHaveLength(1);\n      expect(processed.next_review_date).toBeInstanceOf(Date);\n    });\n\n    test('should update mastery level based on performance', () => {\n      let card = testCard;\n      \n      // Initially new\n      expect(card.mastery_level).toBe('new');\n      \n      // After first review, should be learning\n      card = algorithmInterface.processReview(card, reviewResponse);\n      expect(card.mastery_level).toBe('learning');\n      \n      // Simulate progression to mature\n      for (let i = 0; i < 5; i++) {\n        card = algorithmInterface.processReview(card, { ...reviewResponse, quality: 5 });\n      }\n      \n      // Should eventually become mature or mastered\n      expect(['young', 'mature', 'mastered']).toContain(card.mastery_level);\n    });\n  });\n\n  describe('getCardsDue', () => {\n    let cards: UnifiedCard[];\n\n    beforeEach(() => {\n      cards = [];\n      const now = new Date();\n      \n      // Create overdue card\n      const overdueCard = algorithmInterface.createCard('overdue', userId, 'sm2');\n      overdueCard.next_review_date = new Date(now.getTime() - 60000);\n      cards.push(overdueCard);\n      \n      // Create future card\n      const futureCard = algorithmInterface.createCard('future', userId, 'sm2');\n      futureCard.next_review_date = new Date(now.getTime() + 60000);\n      cards.push(futureCard);\n      \n      // Create due card\n      const dueCard = algorithmInterface.createCard('due', userId, 'sm2');\n      dueCard.next_review_date = now;\n      cards.push(dueCard);\n    });\n\n    test('should return only cards due for review', () => {\n      const dueCards = algorithmInterface.getCardsDue(cards);\n      \n      expect(dueCards).toHaveLength(2);\n      expect(dueCards.map(c => c.phrase_id)).toContain('overdue');\n      expect(dueCards.map(c => c.phrase_id)).toContain('due');\n      expect(dueCards.map(c => c.phrase_id)).not.toContain('future');\n    });\n\n    test('should filter by algorithm type when specified', () => {\n      // Add cards of different algorithms\n      cards.push(algorithmInterface.createCard('leitner-due', userId, 'leitner'));\n      \n      const sm2DueCards = algorithmInterface.getCardsDue(cards, 'sm2');\n      expect(sm2DueCards.every(c => c.algorithm_type === 'sm2')).toBe(true);\n      \n      const leitnerDueCards = algorithmInterface.getCardsDue(cards, 'leitner');\n      expect(leitnerDueCards.every(c => c.algorithm_type === 'leitner')).toBe(true);\n    });\n\n    test('should sort by priority (overdue first, then by mastery)', () => {\n      const now = new Date();\n      \n      // Create cards with different priorities\n      const newOverdue = algorithmInterface.createCard('new-overdue', userId, 'sm2');\n      newOverdue.next_review_date = new Date(now.getTime() - 120000);\n      newOverdue.mastery_level = 'new';\n      \n      const learningOverdue = algorithmInterface.createCard('learning-overdue', userId, 'sm2');\n      learningOverdue.next_review_date = new Date(now.getTime() - 60000);\n      learningOverdue.mastery_level = 'learning';\n      \n      const priorityCards = [newOverdue, learningOverdue];\n      const sorted = algorithmInterface.getCardsDue(priorityCards);\n      \n      // More overdue should come first\n      expect(sorted[0].phrase_id).toBe('new-overdue');\n    });\n  });\n\n  describe('generateStudySession', () => {\n    let cards: UnifiedCard[];\n    let config: StudySessionConfig;\n\n    beforeEach(() => {\n      cards = [];\n      const now = new Date();\n      \n      // Create new cards\n      for (let i = 0; i < 15; i++) {\n        cards.push(algorithmInterface.createCard(`new-${i}`, userId, 'sm2'));\n      }\n      \n      // Create due cards\n      for (let i = 0; i < 25; i++) {\n        const card = algorithmInterface.createCard(`due-${i}`, userId, 'sm2');\n        card.next_review_date = new Date(now.getTime() - i * 60000);\n        card.total_reviews = 1;\n        cards.push(card);\n      }\n      \n      // Create struggling cards\n      for (let i = 0; i < 5; i++) {\n        const card = algorithmInterface.createCard(`struggling-${i}`, userId, 'sm2');\n        card.streak_incorrect = 3;\n        card.total_reviews = 5;\n        card.correct_reviews = 2;\n        cards.push(card);\n      }\n      \n      config = {\n        algorithm_type: 'sm2',\n        max_new_cards: 10,\n        max_review_cards: 20,\n        target_accuracy: 0.8,\n        session_time_limit: 30,\n        difficulty_distribution: {\n          easy: 30,\n          medium: 50,\n          hard: 20,\n        },\n        adaptive_features: {\n          dynamic_difficulty: true,\n          fatigue_detection: true,\n          performance_optimization: true,\n        },\n      };\n    });\n\n    test('should generate session with correct card limits', () => {\n      const session = algorithmInterface.generateStudySession(cards, config);\n      \n      expect(session.session_plan.new_cards).toHaveLength(10);\n      expect(session.session_plan.review_cards.length).toBeLessThanOrEqual(20);\n      expect(session.session_plan.reinforcement_cards.length).toBeGreaterThan(0);\n    });\n\n    test('should include struggling cards in reinforcement', () => {\n      const session = algorithmInterface.generateStudySession(cards, config);\n      \n      const reinforcementIds = session.session_plan.reinforcement_cards.map(c => c.phrase_id);\n      expect(reinforcementIds.some(id => id.startsWith('struggling-'))).toBe(true);\n    });\n\n    test('should estimate session duration', () => {\n      const session = algorithmInterface.generateStudySession(cards, config);\n      \n      expect(session.estimated_duration).toBeGreaterThan(0);\n      expect(session.estimated_duration).toBeLessThan(120); // Reasonable upper bound\n    });\n\n    test('should optimize card order for learning', () => {\n      const session = algorithmInterface.generateStudySession(cards, config);\n      \n      expect(session.session_cards.length).toBeGreaterThan(0);\n      // Cards should be mixed (not all new cards first, then all review cards)\n      const newCardIndices = session.session_cards\n        .map((card, index) => ({ card, index }))\n        .filter(({ card }) => card.total_reviews === 0)\n        .map(({ index }) => index);\n      \n      if (newCardIndices.length > 1) {\n        const isInterleaved = newCardIndices.some((index, i) => \n          i > 0 && index - newCardIndices[i - 1] > 1\n        );\n        expect(isInterleaved).toBe(true);\n      }\n    });\n\n    test('should filter by algorithm type', () => {\n      // Add cards of different algorithms\n      cards.push(algorithmInterface.createCard('leitner-card', userId, 'leitner'));\n      \n      const session = algorithmInterface.generateStudySession(cards, config);\n      \n      // All session cards should be SM-2\n      expect(session.session_cards.every(c => c.algorithm_type === 'sm2')).toBe(true);\n    });\n  });\n\n  describe('updateLearningCurve', () => {\n    test('should create initial model for new user', () => {\n      const sessionResult = {\n        session_id: 'test-session-' + Date.now(),\n        cards_studied: [algorithmInterface.createCard('test', userId, 'sm2')],\n        responses: [],\n        session_stats: {\n          duration_minutes: 20,\n          accuracy: 0.8,\n          average_response_time: 3000,\n          cards_new: 5,\n          cards_review: 10,\n          cards_mastered: 2,\n          difficulty_distribution: { easy: 30, medium: 50, hard: 20 },\n        },\n        algorithm_recommendations: {\n          next_session_config: {},\n          focus_areas: ['accuracy'],\n          estimated_mastery_progress: 0.3,\n        },\n      };\n      \n      algorithmInterface.updateLearningCurve(userId, sessionResult);\n      \n      // Should not throw error and should store model internally\n      expect(() => algorithmInterface.updateLearningCurve(userId, sessionResult)).not.toThrow();\n    });\n  });\n\n  describe('getPerformanceAnalytics', () => {\n    test('should generate performance analytics', () => {\n      const sessions = [{\n        session_id: 'test-session',\n        cards_studied: [],\n        responses: [],\n        session_stats: {\n          duration_minutes: 20,\n          accuracy: 0.8,\n          average_response_time: 3000,\n          cards_new: 5,\n          cards_review: 10,\n          cards_mastered: 2,\n          difficulty_distribution: { easy: 30, medium: 50, hard: 20 },\n        },\n        algorithm_recommendations: {\n          next_session_config: {},\n          focus_areas: ['accuracy'],\n          estimated_mastery_progress: 0.3,\n        },\n      }];\n      \n      const analytics = algorithmInterface.getPerformanceAnalytics(\n        userId,\n        sessions,\n        { start: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000), end: new Date(), type: 'weekly' }\n      );\n      \n      expect(analytics.metrics).toBeDefined();\n      expect(analytics.insights).toBeDefined();\n    });\n  });\n\n  describe('getRecommendations', () => {\n    test('should provide comprehensive recommendations', () => {\n      const cards = [algorithmInterface.createCard('test', userId, 'sm2')];\n      const sessions = [{\n        session_id: 'test-session',\n        cards_studied: cards,\n        responses: [],\n        session_stats: {\n          duration_minutes: 20,\n          accuracy: 0.8,\n          average_response_time: 3000,\n          cards_new: 5,\n          cards_review: 10,\n          cards_mastered: 2,\n          difficulty_distribution: { easy: 30, medium: 50, hard: 20 },\n        },\n        algorithm_recommendations: {\n          next_session_config: {},\n          focus_areas: ['accuracy'],\n          estimated_mastery_progress: 0.3,\n        },\n      }];\n      \n      const recommendations = algorithmInterface.getRecommendations(userId, cards, sessions);\n      \n      expect(recommendations.session_optimization).toBeDefined();\n      expect(recommendations.difficulty_adjustments).toBeDefined();\n      expect(recommendations.focus_areas).toBeDefined();\n      expect(recommendations.session_optimization.optimal_session_length).toBeGreaterThan(0);\n    });\n\n    test('should suggest algorithm switch when appropriate', () => {\n      const strugglingCards = [];\n      \n      // Create cards with poor performance\n      for (let i = 0; i < 10; i++) {\n        const card = algorithmInterface.createCard(`poor-${i}`, userId, 'sm2');\n        card.total_reviews = 5;\n        card.correct_reviews = 2; // 40% accuracy\n        strugglingCards.push(card);\n      }\n      \n      const sessions = [{\n        session_id: 'test-session',\n        cards_studied: strugglingCards,\n        responses: [],\n        session_stats: {\n          duration_minutes: 20,\n          accuracy: 0.4,\n          average_response_time: 6000,\n          cards_new: 0,\n          cards_review: 10,\n          cards_mastered: 0,\n          difficulty_distribution: { easy: 20, medium: 30, hard: 50 },\n        },\n        algorithm_recommendations: {\n          next_session_config: {},\n          focus_areas: ['retention'],\n          estimated_mastery_progress: 0.1,\n        },\n      }];\n      \n      const recommendations = algorithmInterface.getRecommendations(userId, strugglingCards, sessions);\n      \n      expect(recommendations.algorithm_switch).toBeDefined();\n      expect(recommendations.algorithm_switch?.suggested).toBe('leitner');\n      expect(recommendations.focus_areas).toContain('accuracy_improvement');\n    });\n\n    test('should identify cards needing difficulty adjustment', () => {\n      const cards = [];\n      \n      // Create struggling card\n      const strugglingCard = algorithmInterface.createCard('struggling', userId, 'sm2');\n      strugglingCard.total_reviews = 5;\n      strugglingCard.correct_reviews = 2;\n      cards.push(strugglingCard);\n      \n      // Create easy card\n      const easyCard = algorithmInterface.createCard('easy', userId, 'sm2');\n      easyCard.total_reviews = 5;\n      easyCard.correct_reviews = 5;\n      easyCard.streak_correct = 3;\n      cards.push(easyCard);\n      \n      const recommendations = algorithmInterface.getRecommendations(userId, cards, []);\n      \n      expect(recommendations.difficulty_adjustments.cards_to_simplify).toContain('struggling');\n      expect(recommendations.difficulty_adjustments.cards_to_advance).toContain('easy');\n    });\n  });\n});"